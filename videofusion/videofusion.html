<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>
        易智瑞视频融合计算器
    </title>
    <style>
        html,
        body,
        #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }
    </style>
    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script src="js/three.js"></script>
    <script src="js/delaunay.js"></script>

    <script src="js/calcite-web-master/dist/js/calcite-web.min.js"></script>

    <link rel="stylesheet" href="https://js.arcgis.com/4.21/esri/themes/light/main.css" />
    <script src="https://js.arcgis.com/4.21/"></script>
    <link rel="stylesheet" href="js/calcite-web-master/dist/css/calcite-web.min.css">
</head>

<body>
    <div id="videoDrawer" class="drawer drawer-left js-drawer" data-drawer="top-nav" tabindex="0">
        <li id="exampleLi" style="visibility:hidden">
            <div class="alert modifier-class is-active">
                <mark class="label-green modifier-class">内容</mark>

                <button class="alert-close">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 -2 32 32"
                        class="svg-icon">
                        <path
                            d="M18.404 16l9.9 9.9-2.404 2.404-9.9-9.9-9.9 9.9L3.696 25.9l9.9-9.9-9.9-9.898L6.1 3.698l9.9 9.899 9.9-9.9 2.404 2.406-9.9 9.898z" />
                    </svg>
                </button>
            </div>
        </li>
        <li id="exampleLi2" style="visibility:hidden">
            <div class="alert modifier-class is-active">
                <mark class="label-green modifier-class">beta</mark>
                <button class="alert-close">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 -2 32 32"
                        class="svg-icon">
                        <path
                            d="M18.404 16l9.9 9.9-2.404 2.404-9.9-9.9-9.9 9.9L3.696 25.9l9.9-9.9-9.9-9.898L6.1 3.698l9.9 9.899 9.9-9.9 2.404 2.406-9.9 9.898z" />
                    </svg>
                </button>
            </div>
        </li>
        <li id="exampleLi3" style="visibility:hidden">
            <div class="alert modifier-class is-active">
                <mark class="label-green modifier-class" style="margin-right: 60px;">beta</mark>
                <button class="btn-transparent">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32" class="svg-icon">
                        <path
                            d="M27.443 9.439l-4.955-4.953 1.652-1.65a2.337 2.337 0 0 1 3.301 0l1.648 1.65a2.33 2.33 0 0 1 .004 3.299l-1.65 1.654zM4.924 22.195l-2.373 7.254 7.328-2.301-4.955-4.953zM20.455 6.713L7.379 19.555l4.951 4.949 13.074-12.842-4.949-4.949z" />
                    </svg>
                </button>
                <button class="alert-close">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 -6 32 32"
                        class="svg-icon">
                        <path
                            d="M18.404 16l9.9 9.9-2.404 2.404-9.9-9.9-9.9 9.9L3.696 25.9l9.9-9.9-9.9-9.898L6.1 3.698l9.9 9.899 9.9-9.9 2.404 2.406-9.9 9.898z" />
                    </svg>
                </button>
            </div>
        </li>
        <nav style="width: 960px;height: 1080;" class="drawer-nav" role="navigation">

            <aside class="side-nav">
                <canvas id="videoCanvas"></canvas>
            </aside>
            <ul id="videoPointUL" class="list" style="height:300px;overflow-y:scroll;">
            </ul>

        </nav>
    </div>
    <div id="viewDiv"></div>


    <div id="drawControlPointMenu" style="background-color: #a9a9a9;width: 410px;height: 10px;">
        <aside class="side-nav">
            <div class="modifier-class trailer-2 js-tab-group">
                <nav class="tab-nav">
                    <a id="cornerPointTabBtn" class="tab-title js-tab is-active">视频角点</a>
                    <a id="groundControlPointTabBtn" class="tab-title js-tab">地面视频控制点</a>
                    <a id="highgroundControlPointTabBtn" class="tab-title js-tab">高空视频控制点</a>
                    <a id="castResultTabBtn" class="tab-title js-tab">视频融合</a>
                </nav>
                <section class="tab-contents">
                    <div id="cornerPointTabContent" class="tab-section js-tab-section is-active">
                        <div>
                            <div>
                                <button style="margin-left: 10px;" id="selectTopLeft"
                                    class="btn modifier-class">选择左上角位置</button>
                                <label>
                                    <input id="valueOfTopLeftCorner" type="text" placeholder="左上角坐标"
                                        class="modifier-class" required>
                                </label>
                            </div>
                            <div><button style="margin-left: 10px;" id="selectTopRight"
                                    class="btn modifier-class">选择右上角位置</button>
                                <label>
                                    <input id="valueOfTopRightCorner" type="text" placeholder="右上角坐标"
                                        class="modifier-class" required>
                                </label>
                            </div>
                            <div><button style="margin-left: 10px;" id="selectBottomLeft"
                                    class="btn modifier-class">选择左下角位置</button>
                                <label>
                                    <input id="valueOfBottomLeftCorner" type="text" placeholder="左下角坐标"
                                        class="modifier-class" required>
                                </label>
                            </div>
                            <div><button style="margin-left: 10px;" id="selectBottomRight"
                                    class="btn modifier-class">选择右下角位置</button>
                                <label>
                                    <input id="valueOfBottomRightCorner" type="text" placeholder="右下角坐标"
                                        class="modifier-class" required>
                                </label>
                            </div>
                            <div><mark class="label-green modifier-class ">视频海拔高度</mark> <label>
                                    <input type="text" placeholder="海拔高度(米)" id="currentVideoElevation"
                                        class="modifier-class" required>
                                </label>
                                <button style="margin-left: 10px;" id="updateElevation"
                                    class="btn modifier-class">调整投影面海拔高度</button>
                            </div>
                        </div>
                    </div>
                    <div id="controlPointTabContent" class="tab-section js-tab-section">
                        <button style="margin-left: 10px;" id="addMapGroundControlPntBtn"
                            class="btn modifier-class">添加地面控制点</button>
                        <ul id="MapPointUL" class="list2" style="height:300px;overflow-y:scroll;">
                        </ul>
                    </div>
                    <div id="highControlPointTabContent" class="tab-section js-tab-section">
                        <button style="margin-left: 10px;" id="addMapHighPointBtn"
                            class="btn modifier-class">添加高空控制点</button>
                        <div id="editHighControlPointPanel" style="background-color:#ccc;display: none;">
                            <div style="margin-top:5px; margin-bottom:10px; margin-left:5px; margin-right:5px">
                                <label style="font-size:16px;margin-bottom: 10px;">
                                    选择同位置地面点
                                </label>
                                <select id="selector" style="width: 360;" name="gender" required>

                                </select>
                                <label style="font-size:16px;margin-bottom: 10px;">
                                    输入相对高度
                                </label>
                                <input style="font-size:16px;margin-bottom: 10px;" id="relativeElevationValue"
                                    type="number" required>
                                <label style="font-size:16px;margin-bottom: 10px;">
                                    选择视频中同名点
                                </label>
                                <select id="selector2" style="width: 360;" name="gender2" required> </select>
                                <button style="margin-bottom: 5px;" class="btn"
                                    id="editHighControlPointSubmit">提交</button>
                                <button style="margin-bottom: 5px;" class="btn"
                                    id="editHighControlPointCancel">取消</button>
                            </div>
                        </div>
                        <div>
                            <ul id="HighMapPointUL" class="list3" style="height:300px;overflow-y:scroll;">
                            </ul>
                        </div>
                    </div>
                    <div id="castTabContent" class="tab-section js-tab-section">

                        <div>
                            <div>
                                <div>
                                    <button id="castVideo" style="margin-top: 10px;margin-left: 20px;"
                                        class="btn modifier-class">融合视频</button>
                                    <button id="canselCastVideo" style="margin-top: 10px;margin-left: 20px;"
                                        class="btn modifier-class">取消融合</button>
                                </div>
                                <div> <button id="exportCastParam" style="margin-top: 10px;margin-left: 20px;"
                                        class="btn modifier-class">导出视频融合参数</button></div>
                            </div>
                        </div>

                    </div>
                </section>
                <div><button id="openDrawer" style="margin-top: 10px;margin-left: 20px;"
                        class="btn modifier-class">打开视频</button>
                    <label>
                    </label>
                </div>
            </div>
        </aside>
    </div>
    <video controls="controls" muted autoplay="autoplay" loop id="myVideo" width="0" height="0"
        src="video/video.mp4"></video>

</body>

<script>
    require(["esri/Map", "esri/views/SceneView",
        'esri/views/3d/externalRenderers',
        "esri/core/Accessor",
        "esri/layers/MapImageLayer",
        "esri/layers/SceneLayer",
        "esri/geometry/SpatialReference",
        "http://localhost/videofusion/js/yzrVideoCastLayer.js",
        "esri/layers/IntegratedMeshLayer",
        "esri/geometry/Polygon",
        "esri/geometry/Polyline",
        "esri/layers/support/SceneModification",
        "esri/layers/support/SceneModifications",
        "esri/layers/GraphicsLayer",
        "esri/Graphic",
        "esri/widgets/Sketch/SketchViewModel",
        "esri/layers/FeatureLayer",
        "esri/layers/support/LabelClass",
        "esri/geometry/geometryEngine",
        "esri/Camera"
    ],
        (Map, SceneView, externalRenderers, Accessor, MapImageLayer, SceneLayer, SpatialReference, yzrVideoCastLayer, IntegratedMeshLayer, Polygon, Polyline, SceneModification, SceneModifications, GraphicsLayer, Graphic, SketchViewModel, FeatureLayer, LabelClass, geometryEngine, Camera) => {


            function intersection(p1, p2, times) {
                var stepx = (p2[0] - p1[0]) / times;
                var stepy = (p2[1] - p1[1]) / times;
                var newarray = new Array();
                for (var i = 0; i < times; i++) {
                    newarray.push([p1[0] + i * stepx, p1[1] + i * stepy]);
                }
                newarray.push([p2[0], p2[1]]);
                return newarray;
            }
            function intersectionMapPointIn3D(point1, point2, times) {
                var stepx = (point2.x - point1.x) / times;
                var stepy = (point2.y - point1.y) / times;
                var stepz = (point2.z - point1.z) / times;
                var newarray = new Array();
                for (var i = 0; i < times; i++) {
                    let point = {
                        type: "point",  // autocasts as new Point()
                        x: point1.x + i * stepx,
                        y: point1.y + i * stepy,
                        z: point1.z + i * stepz,
                        spatialReference: { wkid: 102100 }
                    };
                    newarray.push(point);
                }
                newarray.push(point2);
                return newarray;
            }
            //倾斜摄影图层
            let myIntegratedMeshLayer = new IntegratedMeshLayer({
                url: "https://tiles.arcgis.com/tiles/3VZsTPsaF6yfc9s5/arcgis/rest/services/%E9%AB%98%E6%96%B0%E4%B9%9D%E5%8F%B7/SceneServer",
                elevationInfo: {
                    mode: "absolute-height",
                    offset: -60,
                    unit: "meters"
                }
            });
            //视频DOM元素
            var video = document.getElementById("myVideo");
            //视频控制点坐标数组，元素值以像素为单位
            var videoControlPointArray = new Array();
            //投影最终需要的视频坐标数组
            var castVideoCoords;
            //投影最终需要的视频坐标顺序数组，数组元素个数为3的倍数
            var castVideoSequence;
            //投影最终需要的地图坐标数组
            var castMapCoords = new Array();
            //投影最终需要的地图坐标顺序数组，数组元素个数为3的倍数
            var castMapSequence = new Array();
            //地图高空点与视频点的对应关系，如地图高空点B'对应视频中的A点，则存储[B,A]
            var controlPointMapingArray = new Array();
            //用户自定义的视频投影面高度
            var videoElevation = 0;
            //用户绘制高程点的点图层
            var controlPointFeatureLayer;
            //绘制蒂洛尼三角形的面图层
            var delaunayGraphicLayer = new GraphicsLayer({
                title: "delaunay",
            });
            //绘制地图与视频关联线的线图层
            var lineGraphicLayer = new GraphicsLayer({
                title: "line",
            });
            //外部渲染器,用户渲染投放的视频
            var castVideoRenderer = null;
            //地图中当前点击的绘制按钮(左上、右上、左下、右下)
            var currentCorner = -1;
            var leftTopCornerChecked = false;
            var rightTopCornerChecked = false;
            var leftBottomCornerChecked = false;
            var rightBottomCornerChecked = false;
            var sketchViewModel;
            //地图四个角点
            let defaultPoint1 = {
                type: "point",  // autocasts as new Point()
                longitude: 0,
                latitude: 1,
                x: 0,
                y: 1,
                z: 0
            };
            let defaultPoint2 = {
                type: "point",  // autocasts as new Point()
                longitude: 1,
                latitude: 1,
                x: 1,
                y: 1,
                z: 0
            };
            let defaultPoint3 = {
                type: "point",  // autocasts as new Point()
                longitude: 1,
                latitude: 0,
                x: 1,
                y: 0,
                z: 0
            };
            let defaultPoint4 = {
                type: "point",  // autocasts as new Point()
                longitude: 0,
                latitude: 0,
                x: 0,
                y: 0,
                z: 0
            };
            //构造四个地图角点的Graphic
            var topLeftPointGraphic = new Graphic({
                geometry: defaultPoint1,
                attributes: {
                    "ObjectID": 1,
                    "name": "左上角",
                }
            });
            var topRightPointGraphic = new Graphic({
                geometry: defaultPoint2,
                attributes: {
                    "ObjectID": 2,
                    "name": "右上角",
                }
            });
            var bottomLeftPointGraphic = new Graphic({
                geometry: defaultPoint3,
                attributes: {
                    "ObjectID": 3,
                    "name": "左下角",
                }
            });
            var bottomRightPointGraphic = new Graphic({
                geometry: defaultPoint4,
                attributes: {
                    "ObjectID": 4,
                    "name": "右下角",
                }
            });
            //四个角点的数组，左上，右上，左下，右下的顺序
            var cornerGeometryArray = new Array(defaultPoint1, defaultPoint2, defaultPoint3, defaultPoint4);
            //地图中地面控制点坐标数组
            var mapGroundControlGeometryArray = new Array();
            //地图中高空控制点坐标数组，存储结构为['B',Point对象]
            var mapHighControlGeometryArray = new Array();
            //将以像素为单位的坐标，归一化为以0-1的比例表示的坐标
            function normalizeVideoCoords(height, width, array) {
                var resultArray = new Array();
                for (var i = 0; i < array.length; i++) {
                    resultArray.push([array[i][0] / height, (width - array[i][1]) / width]);
                }
                return resultArray;
            }
            //字母转数字0-A 1-B
            function charToNum(c) {
                return c.charCodeAt(0) - 65;
            }
            //数字转字母A-0 B-1
            function numToChar(c) {
                return (c + 10).toString(36).toUpperCase();
            }
            //重绘视频Canvas
            function reDrawCanvas() {
                var canvas = document.getElementById("videoCanvas");
                ctx = canvas.getContext("2d");
                ctx.font = "16px bold 宋体";
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#00FFFF";
                canvas.width = 960;
                var scale = 960 / video.videoWidth;
                canvas.height = video.videoHeight * scale;
                canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
                draw4Corner(ctx, canvas);
                //动态画鼠标点击点，点位置和点的文字
                for (var i = 0; i < videoControlPointArray.length; i++) {

                    var x = videoControlPointArray[i][0];
                    var y = videoControlPointArray[i][1];
                    ctx.fillRect(x, y, 8, 8);
                    if (y == 0) {
                        y = y + 20;
                    }
                    ctx.fillText("控制点" + numToChar(i), x + 10, y);

                }

                var videoControlPointPX = new Array();
                var vertices = new Array();

                vertices[0] = [0, 0];
                vertices[1] = [canvas.width, 0];
                vertices[2] = [0, canvas.height];
                vertices[3] = [canvas.width, canvas.height];

                videoControlPointPX.push(vertices[0]);
                videoControlPointPX.push(vertices[1]);
                videoControlPointPX.push(vertices[2]);
                videoControlPointPX.push(vertices[3]);
                videoControlPointArray.forEach(element => {
                    var point = [element[0], element[1]];
                    videoControlPointPX.push(point);
                });

                var triangle0 = Delaunay.triangulate(videoControlPointPX);
                let triangles = reOrderDelaunay(triangle0, videoControlPointPX);
                castVideoSequence = triangles;
                if (castMapSequence) {
                    castMapSequence.length = 0;
                    castMapSequence = castMapSequence.concat(castVideoSequence);
                }
                //每个循环是一个三角形
                for (var i = 0; i < castVideoSequence.length / 3; i++) {
                    var index1 = castVideoSequence[i * 3] - 4;
                    var index2 = castVideoSequence[i * 3 + 1] - 4;
                    var index3 = castVideoSequence[i * 3 + 2] - 4;
                    var exist1 = -1, exist2 = -1, exist3 = -1;
                    if (controlPointMapingArray.length <= 0)
                        continue;
                    var mappingIndex = -1;
                    let currentDelaunayTraigleArray = new Array(index1, index2, index3)
                    //如果每个值都在映射表中，则这个三角形需要改值
                    var index1Exist = -1, index2Exist = -1, index3Exist = -1;

                    for (var j = 0; j < controlPointMapingArray.length; j++) {
                        if (index1Exist == -1) { index1Exist = controlPointMapingArray[j].indexOf(numToChar(index1)) }
                        if (index2Exist == -1) { index2Exist = controlPointMapingArray[j].indexOf(numToChar(index2)) }
                        if (index3Exist == -1) { index3Exist = controlPointMapingArray[j].indexOf(numToChar(index3)) }
                    }
                    //此IF下，三角形改值
                    if (index1Exist != -1 && index2Exist != -1 && index3Exist != -1) {

                        for (var n = 0; n < currentDelaunayTraigleArray.length; n++) {

                            for (var l = 0; l < controlPointMapingArray.length; l++) {
                                if (controlPointMapingArray[l][1] == numToChar(currentDelaunayTraigleArray[n])) {
                                    if (n == 0) {
                                        castMapSequence[i * 3 + n] = castMapSequence[i * 3 + 1]
                                    }
                                    else {
                                        castMapSequence[i * 3 + n] = castMapSequence[i * 3 + n - 1]
                                    }

                                }
                            }
                        }
                    }
                    else {
                    }
                }
                //将坐标归一化，即得到比例坐标
                castVideoCoords = normalizeVideoCoords(canvas.width, canvas.height, videoControlPointPX);

                for (var i = 0; i < triangles.length / 3; i++) {
                    ctx.beginPath();
                    ctx.strokeStyle = "#e8912e"
                    ctx.moveTo(videoControlPointPX[triangles[i * 3]][0], videoControlPointPX[triangles[i * 3]][1]);
                    ctx.lineTo(videoControlPointPX[triangles[i * 3 + 1]][0], videoControlPointPX[triangles[i * 3 + 1]][1]);
                    ctx.lineTo(videoControlPointPX[triangles[i * 3 + 2]][0], videoControlPointPX[triangles[i * 3 + 2]][1]);

                    var index1 = [triangles[i * 3]][0];
                    var index2 = [triangles[i * 3 + 1]][0];
                    var index3 = [triangles[i * 3 + 2]][0];
                    var x1 = videoControlPointPX[index1][0];
                    var y1 = videoControlPointPX[index1][1];
                    var x2 = videoControlPointPX[index2][0];
                    var y2 = videoControlPointPX[index2][1];
                    var x3 = videoControlPointPX[index3][0];
                    var y3 = videoControlPointPX[index3][1];
                    ctx.fillText("面" + numToChar(i), (x1 + x2 + x3) / 3, (y1 + y2 + y3) / 3);
                    ctx.closePath();
                    ctx.stroke();
                }
            }
            //绘制Video的四个角点、角点文字
            function draw4Corner(ctx, canvas) {
                var vertices = new Array();
                vertices[0] = [0, canvas.height];
                vertices[1] = [canvas.width, canvas.height];
                vertices[2] = [canvas.width, 0];
                vertices[3] = [0, 0];

                ctx.fillStyle = "#00FFFF";
                ctx.font = "16px bold 宋体";
                //ctx.fillText("左上角(0,1)", 20, 20);
                ctx.fillRect(0, 0, 8, 8);

                //ctx.fillText("右上角(1,1)", canvas.width - 90, 20);
                ctx.fillRect(canvas.width - 10, 0, 8, 8);


                //ctx.fillText("左下角(0,0)", 20, canvas.height - 10);
                ctx.fillRect(0, canvas.height - 8, 8, 8);

                //ctx.fillText("右下角(0,0)", canvas.width - 90, canvas.height - 10);
                ctx.fillRect(canvas.width - 8, canvas.height - 8, 8, 8);
            }
            const map = new Map({
                basemap: "hybrid",
                ground: "world-elevation"
            });
            map.add(delaunayGraphicLayer);
            map.add(lineGraphicLayer);
            const view = new SceneView({
                container: "viewDiv",
                map: map,
                scale: 500,
            });
            //对蒂洛尼三角网生成的序列数组进行排序，使三角形的三个点坐标逆时针排列（three.js要求三角形逆时针），如，蒂洛尼给出A B C三点，将固定A在第一位，则有两种三角形构造法，ABC或ACB。如果ABC顺序为逆时针，则不动；如果ABC为顺时针，则将坐标变为ACB
            function reOrderDelaunay(delaunay, originArray) {
                var resultArray = new Array();
                for (var i = 0; i < delaunay.length / 3; i++) {
                    resultArray.push(delaunay[i * 3]);
                    var p1 = delaunay[i * 3];//序号
                    var p2 = delaunay[i * 3 + 1];
                    var p3 = delaunay[i * 3 + 2];
                    var p1x = originArray[p1][0];
                    var p1y = originArray[p1][1];
                    var p2x = originArray[p2][0];
                    var p2y = originArray[p2][1];
                    var p3x = originArray[p3][0];
                    var p3y = originArray[p3][1];

                    var value = (p2x - p1x) * (p3y - p1y) - (p2y - p1y) * (p3x - p1x);
                    if (value < 0) {
                        resultArray.push(delaunay[i * 3 + 1]);
                        resultArray.push(delaunay[i * 3 + 2]);
                    }
                    else {
                        resultArray.push(delaunay[i * 3 + 2]);
                        resultArray.push(delaunay[i * 3 + 1]);
                    }
                }
                return resultArray;
            }
            //地图内容有修改后重绘地图
            function refreshMap() {
                //清除图层
                for (var i = 0; i < map.layers.length; i++) {
                    if (map.layers.getItemAt(i).title == "controlPointLayer") { map.layers.remove(map.layers.getItemAt(i)); }
                }
                delaunayGraphicLayer.graphics.removeAll();
                lineGraphicLayer.graphics.removeAll();
                //显示控制点地图位置，先加入4个视频角点，再加入地面控制点，最后加入高空控制点
                var mapControlGraphicArray = new Array();

                topLeftPointGraphic.geometry = cornerGeometryArray[0];
                topRightPointGraphic.geometry = cornerGeometryArray[1];
                bottomLeftPointGraphic.geometry = cornerGeometryArray[2];
                bottomRightPointGraphic.geometry = cornerGeometryArray[3];

                mapControlGraphicArray.push(topLeftPointGraphic)
                mapControlGraphicArray.push(topRightPointGraphic)
                mapControlGraphicArray.push(bottomLeftPointGraphic)
                mapControlGraphicArray.push(bottomRightPointGraphic)

                castMapCoords.length = 0;
                castMapCoords.push(cornerGeometryArray[0])
                castMapCoords.push(cornerGeometryArray[1])
                castMapCoords.push(cornerGeometryArray[2])
                castMapCoords.push(cornerGeometryArray[3])

                //处理地面控制点，标注为B
                for (var i = 0; i < mapGroundControlGeometryArray.length; i++) {
                    let tempgeometry = mapGroundControlGeometryArray[i];
                    castMapCoords.push(tempgeometry);
                    tempgeometry.z = videoElevation;
                    var graphic = new Graphic({
                        geometry: tempgeometry,
                        attributes: {
                            "ObjectID": i + 5,
                            "name": "点" + numToChar(i),
                        }
                    });
                    mapControlGraphicArray.push(graphic);
                }
                //处理高空控制点，标注为B'
                for (var i = 0; i < mapHighControlGeometryArray.length; i++) {
                    var tempgeometry = mapHighControlGeometryArray[i][1];
                    var graphic = new Graphic({
                        geometry: tempgeometry,
                        attributes: {
                            "ObjectID": 100 + i,
                            "name": "点" + mapHighControlGeometryArray[i][0] + "'",
                        }
                    });
                    mapControlGraphicArray.push(graphic);

                }

                if (mapControlGraphicArray.length == 0)
                    return
                controlPointFeatureLayer = new FeatureLayer({
                    fields: [{
                        name: "ObjectID",
                        alias: "ObjectID",
                        type: "oid"
                    }, {
                        name: "name",
                        alias: "名称",
                        type: "string"
                    }],
                    source: mapControlGraphicArray,
                    title: "controlPointLayer",
                    objectIdField: "ObjectID",
                    labelingInfo: [new LabelClass({
                        labelPlacement: "above-center",
                        labelExpressionInfo: { expression: 'DefaultValue($feature.name, "no data")' },
                        symbol: {
                            type: "text",  // autocasts as new TextSymbol()
                            color: "orange",
                            haloSize: 1,
                            haloColor: "white"
                        }
                    })]
                });
                controlPointFeatureLayer.elevationInfo = {
                    mode: "absolute-height",
                    offset: 0,
                };
                controlPointFeatureLayer.renderer = {
                    type: "simple",  // autocasts as new SimpleRenderer()
                    symbol: {
                        type: "simple-marker",  // autocasts as new SimpleMarkerSymbol()
                        size: 10,
                        color: [51, 128, 51],
                        outline: {  // autocasts as new SimpleLineSymbol()
                            width: 2,
                            color: "white"
                        }
                    }
                };
                map.add(controlPointFeatureLayer);

                //构建二维坐标的数组，用于计算蒂洛尼三角网，蒂洛尼计算只能在二维
                var dimetion2Array = new Array();
                //构建三维坐标数组，用于地图中显示蒂洛尼
                var tempGCGeometryArray = new Array();
                dimetion2Array.push([cornerGeometryArray[0].x, cornerGeometryArray[0].y])
                dimetion2Array.push([cornerGeometryArray[1].x, cornerGeometryArray[1].y])
                dimetion2Array.push([cornerGeometryArray[2].x, cornerGeometryArray[2].y])
                dimetion2Array.push([cornerGeometryArray[3].x, cornerGeometryArray[3].y])
                tempGCGeometryArray.push([cornerGeometryArray[0].x, cornerGeometryArray[0].y, cornerGeometryArray[0].z]);
                tempGCGeometryArray.push([cornerGeometryArray[1].x, cornerGeometryArray[1].y, cornerGeometryArray[1].z])
                tempGCGeometryArray.push([cornerGeometryArray[2].x, cornerGeometryArray[2].y, cornerGeometryArray[2].z])
                tempGCGeometryArray.push([cornerGeometryArray[3].x, cornerGeometryArray[3].y, cornerGeometryArray[3].z])
                for (var i = 0; i < mapGroundControlGeometryArray.length; i++) {
                    dimetion2Array.push([mapGroundControlGeometryArray[i].x, mapGroundControlGeometryArray[i].y]);
                    tempGCGeometryArray.push([mapGroundControlGeometryArray[i].x, mapGroundControlGeometryArray[i].y, mapGroundControlGeometryArray[i].z])
                }
                //蒂洛尼三角网是二维的
                var triangles = Delaunay.triangulate(dimetion2Array);
                const delaunayfillSymbol = {
                    type: "simple-fill",
                    color: [51, 51, 204, 0.35],
                    outline: {
                        color: "white",
                        width: 2
                    }
                };
                //地图中绘制蒂洛尼三角网需要三维的面要素 
                var delaunayPolygonGraphicArray = new Array();
                for (var i = 0; i < triangles.length / 3; i++) {
                    var point1 = [tempGCGeometryArray[triangles[i * 3]][0], tempGCGeometryArray[triangles[i * 3]][1], tempGCGeometryArray[triangles[i * 3]][2]];
                    var point2 = [tempGCGeometryArray[triangles[i * 3 + 1]][0], tempGCGeometryArray[triangles[i * 3 + 1]][1], tempGCGeometryArray[triangles[i * 3 + 1]][2]];
                    var point3 = [tempGCGeometryArray[triangles[i * 3 + 2]][0], tempGCGeometryArray[triangles[i * 3 + 2]][1], tempGCGeometryArray[triangles[i * 3 + 2]][2]];
                    var rings = [point1, point2, point3, point1];
                    const polygon = new Polygon({
                        rings: rings,
                        spatialReference: { wkid: 102100 }
                    });
                    var polygonGraphic = new Graphic({
                        geometry: polygon,
                        symbol: delaunayfillSymbol,
                        attributes: {
                            "ObjectID": i,
                            "name": "" + numToChar(i),
                        }
                    });
                    delaunayPolygonGraphicArray.push(polygonGraphic);
                }
                //绘制竖起来的蒂洛尼面
                for (var i = 0; i < mapHighControlGeometryArray.length - 1; i++) {

                    let point1 = mapGroundControlGeometryArray[charToNum(mapHighControlGeometryArray[i][0])];
                    let p1 = [point1.x, point1.y, point1.z]
                    let point1H = mapHighControlGeometryArray[i][1];
                    let p1H = [point1H.x + 0.001, point1H.y + 0.001, point1H.z]

                    let point2 = mapGroundControlGeometryArray[charToNum(mapHighControlGeometryArray[i + 1][0])];
                    let p2 = [point2.x, point2.y, point2.z]
                    let point2H = mapHighControlGeometryArray[i + 1][1];
                    let p2H = [point2H.x + 0.001, point2H.y + 0.001, point2H.z]

                    let rings1 = [p1, p1H, p2];
                    let rings2 = [p1H, p2, p2H];
                    const polygon1 = new Polygon({
                        rings: rings1,
                        spatialReference: { wkid: 102100 }
                    });
                    const polygon2 = new Polygon({
                        rings: rings2,
                        spatialReference: { wkid: 102100 }
                    });

                    var polygonGraphic1 = new Graphic({
                        geometry: polygon1,
                        symbol: delaunayfillSymbol,
                    });
                    var polygonGraphic2 = new Graphic({
                        geometry: polygon2,
                        symbol: delaunayfillSymbol,
                    });
                    delaunayPolygonGraphicArray.push(polygonGraphic1);
                    delaunayPolygonGraphicArray.push(polygonGraphic2);
                }
                delaunayGraphicLayer.graphics.addMany(delaunayPolygonGraphicArray);
                //地图与视频对应线图层
                for (var i = 0; i < controlPointMapingArray.length; i++) {
                    point1Name = controlPointMapingArray[i][0];
                    var point1;

                    for (var j = 0; j < mapHighControlGeometryArray.length; j++) {
                        if (point1Name == mapHighControlGeometryArray[j][0]) {
                            point1 = mapHighControlGeometryArray[j][1];
                        }
                    }
                    point2 = mapGroundControlGeometryArray[charToNum(controlPointMapingArray[i][1])];
                    if(!point2)
                    continue
                    let paths = [
                        [
                            [point1.x, point1.y, point1.z],
                            [point2.x, point2.y, point2.z]
                        ]
                    ];
                    let line = new Polyline({
                        paths: paths,
                        spatialReference: { wkid: 102100 }
                    });
                    const lineSymbol = {
                        type: "simple-line",
                        color: [226, 119, 40],
                        width: 4
                    };
                    const polylineGraphic = new Graphic({
                        geometry: line,
                        symbol: lineSymbol
                    });
                    lineGraphicLayer.graphics.add(polylineGraphic);
                }
            }

            refreshMap();
            let myMapImageLayer = new MapImageLayer({
                url: "https://snk.runtime.com/server/rest/services/tube/MapServer"
            });

            const fillSymbol = {
                type: "simple-fill", // autocasts as new SimpleFillSymbol()
                color: [0, 0, 255, 0.8],
                outline: {
                    // autocasts as new SimpleLineSymbol()
                    color: [255, 255, 255],
                    width: 2
                }
            };
            const drawingPointSymbol = {
                type: "simple-marker",
                color: [226, 119, 40],
                outline: {
                    color: [255, 255, 255],
                    width: 2
                }
            };

            var sketchGraphicLayer = new GraphicsLayer();
            view.map.add(sketchGraphicLayer)
            sketchViewModel = new SketchViewModel({
                layer: sketchGraphicLayer,
                view: view,
                creationMode: "update",
                snappingOptions: {
                    enabled: true,
                    featureSources: [{ layer: delaunayGraphicLayer }]
                }
            });
            document.getElementById("selectTopLeft").addEventListener("click", (event) => {

                sketchViewModel.create("point");
                currentCorner = 0;
            });
            document.getElementById("selectTopRight").addEventListener("click", (event) => {

                sketchViewModel.create("point");
                currentCorner = 1;
            });
            document.getElementById("selectBottomLeft").addEventListener("click", (event) => {

                sketchViewModel.create("point");
                currentCorner = 2;
            });
            document.getElementById("selectBottomRight").addEventListener("click", (event) => {

                sketchViewModel.create("point");
                currentCorner = 3;
            });
            document.getElementById("openDrawer").addEventListener("click", (event) => {
                document.getElementById("videoDrawer").classList.add("is-active");
                reDrawCanvas();
                event.stopPropagation();
            });
            document.getElementById("videoDrawer").addEventListener("click", (event) => {
                document.getElementById("videoDrawer").classList.remove("is-active");
            });
            //视频中点击事件，即添加视频控制点
            document.getElementById("videoCanvas").addEventListener("click", (event) => {
                var canvas = document.getElementById("videoCanvas");
                ctx = canvas.getContext("2d");
                var x = event.clientX;
                var y = event.clientY;
                if (event.clientY < 10) {
                    alert("已捕捉到边");
                    y = 0;
                }
                var point = new Array(x, y)
                videoControlPointArray.push(point);

                reDrawCanvas();
                var li = $("#exampleLi").clone();
                li[0].children[0].children[0].innerText = "控制点" + numToChar(videoControlPointArray.length - 1);
                li[0].children[0].children[0].title = numToChar(videoControlPointArray.length - 1);

                li[0].style.visibility = "visible";
                li.appendTo($(".list"));
                event.stopPropagation();
            });
            //角点Tab
            document.getElementById("cornerPointTabBtn").addEventListener("click", (event) => {
                document.getElementById("cornerPointTabBtn").classList.add("is-active");
                document.getElementById("cornerPointTabContent").classList.add("is-active");

                document.getElementById("groundControlPointTabBtn").classList.remove("is-active");
                document.getElementById("controlPointTabContent").classList.remove("is-active");
                document.getElementById("highgroundControlPointTabBtn").classList.remove("is-active");
                document.getElementById("highControlPointTabContent").classList.remove("is-active");
                document.getElementById("castResultTabBtn").classList.remove("is-active");
                document.getElementById("castTabContent").classList.remove("is-active");

            });
            //地面控制点Tab
            document.getElementById("groundControlPointTabBtn").addEventListener("click", (event) => {
                if (leftTopCornerChecked == true && rightTopCornerChecked == true && leftBottomCornerChecked == true && rightBottomCornerChecked == true) {
                    document.getElementById("groundControlPointTabBtn").classList.add("is-active");
                    document.getElementById("controlPointTabContent").classList.add("is-active");

                    document.getElementById("cornerPointTabBtn").classList.remove("is-active");
                    document.getElementById("cornerPointTabContent").classList.remove("is-active");
                    document.getElementById("highgroundControlPointTabBtn").classList.remove("is-active");
                    document.getElementById("highControlPointTabContent").classList.remove("is-active");
                    document.getElementById("castResultTabBtn").classList.remove("is-active");
                    document.getElementById("castTabContent").classList.remove("is-active");
                }
                else {
                    alert("请先绘制视频四个角点。");
                }
            });
            //高空控制点Tab
            document.getElementById("highgroundControlPointTabBtn").addEventListener("click", (event) => {
                if (mapGroundControlGeometryArray.length == 0) {
                    alert("请先绘制地面控制点。");
                    return;
                }
                if (videoControlPointArray.length == 0) {
                    alert("请先绘制视频控制点。")
                    return;
                }
                document.getElementById("highgroundControlPointTabBtn").classList.add("is-active");
                document.getElementById("highControlPointTabContent").classList.add("is-active");

                document.getElementById("groundControlPointTabBtn").classList.remove("is-active");
                document.getElementById("controlPointTabContent").classList.remove("is-active");
                document.getElementById("cornerPointTabBtn").classList.remove("is-active");
                document.getElementById("cornerPointTabContent").classList.remove("is-active");
                document.getElementById("castResultTabBtn").classList.remove("is-active");
                document.getElementById("castTabContent").classList.remove("is-active");
                resetSelector();
            });
            //视频融合Tab
            document.getElementById("castResultTabBtn").addEventListener("click", (event) => {
                document.getElementById("castResultTabBtn").classList.add("is-active");
                document.getElementById("castTabContent").classList.add("is-active");

                document.getElementById("highgroundControlPointTabBtn").classList.remove("is-active");
                document.getElementById("highControlPointTabContent").classList.remove("is-active");
                document.getElementById("groundControlPointTabBtn").classList.remove("is-active");
                document.getElementById("controlPointTabContent").classList.remove("is-active");
                document.getElementById("cornerPointTabBtn").classList.remove("is-active");
                document.getElementById("cornerPointTabContent").classList.remove("is-active");
                resetSelector();
            });

            //重置选择器---设置高空控制点时
            function resetSelector() {
                var selector = document.getElementById("selector");
                selector.options.length = 0;
                for (var i = 0; i < mapGroundControlGeometryArray.length; i++) {
                    selector.options.add(new Option(numToChar(i), numToChar(i)));
                }

                var selector2 = document.getElementById("selector2");
                selector2.options.length = 0;
                if (!videoControlPointArray)
                    return;
                for (var i = 0; i < videoControlPointArray.length; i++) {
                    selector2.options.add(new Option("视频点" + numToChar(i), numToChar(i)));
                }
            }
            //绘制高空点form提交
            document.getElementById("editHighControlPointSubmit").addEventListener("click", (event) => {
                document.getElementById("editHighControlPointPanel").style.display = "none";

                var selector = document.getElementById("selector");
                var selector2 = document.getElementById("selector2");
                var relativeElevationValue = document.getElementById("relativeElevationValue");

                var exist = -1;
                for (var i = 0; i < mapHighControlGeometryArray.length; i++) {
                    if (mapHighControlGeometryArray[i][0] == selector.options[selector.selectedIndex].value) {
                        exist = i;
                        var index = charToNum(selector.options[selector.selectedIndex].value);
                        let point = {
                            type: "point",  // autocasts as new Point()
                            longitude: mapGroundControlGeometryArray[index].longitude,
                            latitude: mapGroundControlGeometryArray[index].latitude,
                            x: mapGroundControlGeometryArray[index].x,
                            y: mapGroundControlGeometryArray[index].y,
                            z: mapGroundControlGeometryArray[index].z + parseFloat(document.getElementById("relativeElevationValue").value),
                            spatialReference: { wkid: 102100 }
                        };
                        mapHighControlGeometryArray[i][1] = point;
                    }
                }
                //不存在，就新增
                if (exist == -1) {
                    let point = {
                        type: "point",  // autocasts as new Point()
                        longitude: mapGroundControlGeometryArray[selector.selectedIndex].longitude,
                        latitude: mapGroundControlGeometryArray[selector.selectedIndex].latitude,
                        x: mapGroundControlGeometryArray[selector.selectedIndex].x,
                        y: mapGroundControlGeometryArray[selector.selectedIndex].y,
                        z: mapGroundControlGeometryArray[selector.selectedIndex].z + parseFloat(document.getElementById("relativeElevationValue").value),
                        spatialReference: { wkid: 102100 }
                    };
                    mapHighControlGeometryArray.push([selector.options[selector.selectedIndex].value, point]);
                    controlPointMapingArray.push([selector.options[selector.selectedIndex].value, selector2.options[selector2.selectedIndex].value]);
                    var li = $("#exampleLi3").clone();
                    li[0].children[0].children[0].innerText = "高空点" + numToChar(selector.selectedIndex) + "'" + "(对应视频点" + numToChar(selector2.selectedIndex) + ")";
                    li[0].children[0].children[0].title = numToChar(selector.selectedIndex) + "+" + numToChar(selector2.selectedIndex) + "+" + relativeElevationValue.value;
                    li[0].style.visibility = "visible";
                    li.appendTo($(".list3"));

                }
                resetSelector();
                refreshMap();

            });
            //绘制高空点form取消
            document.getElementById("editHighControlPointCancel").addEventListener("click", (event) => {
                document.getElementById("editHighControlPointPanel").style.display = "none";
                resetSelector();
            });
            //更新地面控制点海拔高度
            document.getElementById("updateElevation").addEventListener("click", (event) => {
                videoElevation = document.getElementById("currentVideoElevation").value;
                for (var i = 0; i < cornerGeometryArray.length; i++) {
                    cornerGeometryArray[i].z = videoElevation;
                }
                for (var i = 0; i < mapGroundControlGeometryArray.length; i++) {
                    mapGroundControlGeometryArray[i].z = videoElevation;
                }
                refreshMap();
            });
            //删除视频控制点
            document.getElementById("videoPointUL").addEventListener("click", (event) => {
                if (event.target.className == "alert-close") {
                    var lastLi = document.getElementById("videoPointUL").childNodes[document.getElementById("videoPointUL").children.length];
                    document.getElementById("videoPointUL").removeChild(lastLi);
                    var deletIndex = charToNum(event.target.parentNode.children[0].title);
                    videoControlPointArray.splice(deletIndex, 1);
                    reDrawCanvas();
                }
                event.stopPropagation();
            });
            //删除地面控制点
            document.getElementById("MapPointUL").addEventListener("click", (event) => {
                if (event.target.className == "alert-close") {
                    var lastLi = document.getElementById("MapPointUL").childNodes[document.getElementById("MapPointUL").children.length];
                    document.getElementById("MapPointUL").removeChild(lastLi);
                    var deletIndex = charToNum(event.target.parentNode.children[0].title);
                    mapGroundControlGeometryArray.splice(deletIndex, 1);
                    mapHighControlGeometryArray = [];
                    document.getElementById("HighMapPointUL").innerHTML = "";
                    refreshMap();


                }
            });
            //删除高空控制点和编辑高空控制点
            document.getElementById("HighMapPointUL").addEventListener("click", (event) => {
                if (event.target.className == "btn-transparent") {
                    var li = event.target.parentNode.parentNode;
                    var pointname = li.children[0].children[0].title.split("+")
                    //读取当前高空点号
                    var mapIndex = charToNum(pointname[0])
                    var selector = document.getElementById("selector");
                    selector.options.length = 0;
                    selector.add(new Option(numToChar(mapIndex), numToChar(mapIndex)))
                    //读取当前高空点的视频对应点号
                    var videoIndex = charToNum(pointname[1])
                    var selector2 = document.getElementById("selector2");
                    selector2.options.length = 0;
                    selector2.add(new Option(numToChar(videoIndex), numToChar(videoIndex)));
                    //读取当前高空点的相对高度值

                    var relativeElevationValue = pointname[2];
                    var relativeElevation = document.getElementById("relativeElevationValue");
                    relativeElevation.value = relativeElevationValue;

                    document.getElementById("editHighControlPointPanel").style.display = "block"
                }
                if (event.target.className == "alert-close") {
                    var li = event.target.parentNode.parentNode;
                    document.getElementById("HighMapPointUL").removeChild(li);
                    var mychar = li.children[0].children[0].title.split("+")[0]
                    for (i = 0; i < mapHighControlGeometryArray.length; i++) {
                        if (mapHighControlGeometryArray[i][0] == mychar) {
                            mapHighControlGeometryArray.splice(i, 1);
                            break;
                        }
                    }
                    for (var j = 0; j < controlPointMapingArray.length; j++) {
                        if (controlPointMapingArray[i][0] == mychar) {
                            controlPointMapingArray.splice(i, 1);
                            break;
                        }
                    }
                    refreshMap();
                }
            });
            //添加地面控制点按钮
            document.getElementById("addMapGroundControlPntBtn").addEventListener("click", (event) => {
                sketchViewModel.create("point");
                currentCorner = -1;
            });
            //添加高空控制点按钮
            document.getElementById("addMapHighPointBtn").addEventListener("click", (event) => {
                document.getElementById("editHighControlPointPanel").style.display = "block"
            });
            //sketchModel组件，
            sketchViewModel.on("create", (event) => {
                if (event.state === "complete") {
                    sketchGraphicLayer.removeAll();
                    if (currentCorner == 0) {
                        cornerGeometryArray[0] = event.graphic.geometry;
                        var longitude = event.graphic.geometry.longitude.toFixed(4);
                        var latitude = event.graphic.geometry.latitude.toFixed(4);
                        document.getElementById("valueOfTopLeftCorner").value = "经度：" + longitude + "   " + "纬度：" + latitude;
                        leftTopCornerChecked = true;
                    }
                    if (currentCorner == 1) {
                        cornerGeometryArray[1] = event.graphic.geometry;
                        var longitude = event.graphic.geometry.longitude.toFixed(4);
                        var latitude = event.graphic.geometry.latitude.toFixed(4);
                        document.getElementById("valueOfTopRightCorner").value = "经度：" + longitude + "   " + "纬度：" + latitude;
                        rightTopCornerChecked = true;
                    }
                    if (currentCorner == 2) {
                        cornerGeometryArray[2] = event.graphic.geometry;
                        var longitude = event.graphic.geometry.longitude.toFixed(4);
                        var latitude = event.graphic.geometry.latitude.toFixed(4);
                        document.getElementById("valueOfBottomLeftCorner").value = "经度：" + longitude + "   " + "纬度：" + latitude;
                        leftBottomCornerChecked = true;
                    }
                    if (currentCorner == 3) {
                        cornerGeometryArray[3] = event.graphic.geometry;
                        var longitude = event.graphic.geometry.longitude.toFixed(4);
                        var latitude = event.graphic.geometry.latitude.toFixed(4);
                        document.getElementById("valueOfBottomRightCorner").value = "经度：" + longitude + "   " + "纬度：" + latitude;
                        rightBottomCornerChecked = true;
                    }
                    //地面控制点，非视频角点
                    if (currentCorner == -1) {

                        var geometry = event.graphic.geometry;
                        if (videoElevation != 0)
                            geometry.z = videoElevation;
                        mapGroundControlGeometryArray.push(geometry);
                        var li = $("#exampleLi2").clone();
                        li[0].children[0].children[0].innerText = "点" + numToChar(mapGroundControlGeometryArray.length - 1);
                        li[0].children[0].children[0].title = numToChar(mapGroundControlGeometryArray.length - 1);
                        li[0].style.visibility = "visible";
                        li.appendTo($(".list2"));
                    }
                    //计算四个角点的平均海拔
                    var sum = 0;
                    var indexSum = 0;
                    for (var i = 0; i < cornerGeometryArray.length; i++) {
                        if (cornerGeometryArray[i].z != 0) {
                            indexSum++;
                            sum += cornerGeometryArray[0].z;
                        }
                    }
                    if (indexSum != 0) {
                        document.getElementById("currentVideoElevation").value = (sum / indexSum).toFixed(2);
                    }
                    refreshMap();
                }
            });
            //构造立面
            function buildVerticalFace() {
                var castVerticalVideoCoords = new Array();
                var castVerticalVideoSequence = new Array();
                var castVerticalMapCoords = new Array();
                var castVerticalMapSequence = new Array();
                var times = 5;
                for (var i = 0; i < controlPointMapingArray.length - 1; i++) {
                    //先获取构造第一个立面的四个点
                    // A  A1  A2  A3                       D
                    //
                    //
                    //
                    // B  B1  B2  B3                       C
                    var AVideoindex = charToNum(controlPointMapingArray[i][1]);
                    var BVideoindex = charToNum(controlPointMapingArray[i][0]);
                    var CVideoindex = charToNum(controlPointMapingArray[i + 1][0]);
                    var DVideoindex = charToNum(controlPointMapingArray[i + 1][1]);
                    var AVideoPoint = castVideoCoords[AVideoindex + 4];
                    var BVideoPoint = castVideoCoords[BVideoindex + 4];
                    var CVideoPoint = castVideoCoords[CVideoindex + 4];
                    var DVideoPoint = castVideoCoords[DVideoindex + 4];

                    var upperVideoArray = intersection(AVideoPoint, DVideoPoint, times);
                    var lowerVideoArray = intersection(BVideoPoint, CVideoPoint, times);
                    castVerticalVideoCoords = castVerticalVideoCoords.concat(upperVideoArray);
                    castVerticalVideoCoords = castVerticalVideoCoords.concat(lowerVideoArray);
                    //A-B-B1；B-B1-A1；
                    let baseindex = i * (times + 1) * 2;
                    for (var j = 0; j < times; j++) {

                        castVerticalVideoSequence.push([j + baseindex, j + times + 1 + baseindex, j + times + 1 + 1 + baseindex]);
                        castVerticalVideoSequence.push([j + baseindex, j + times + 1 + 1 + baseindex, j + 1 + baseindex])
                    }
                    //处理地图中的
                    var BMapIndex = charToNum(controlPointMapingArray[i][0]);
                    var CMapIndex = charToNum(controlPointMapingArray[i + 1][0]);
                    var BMapPoint = castMapCoords[BMapIndex + 4];
                    var CmapPoint = castMapCoords[CMapIndex + 4];
                    var BHighMapPoint = null;
                    var CHighMapPoint = null;
                    for (var j = 0; j < mapHighControlGeometryArray.length; j++) {
                        //B点
                        if (mapHighControlGeometryArray[j][0] == controlPointMapingArray[i][0]) {
                            BHighMapPoint = mapHighControlGeometryArray[j][1];
                        }
                        if (mapHighControlGeometryArray[j][0] == controlPointMapingArray[i + 1][0]) {
                            CHighMapPoint = mapHighControlGeometryArray[j][1];
                        }
                    }
                    var upperMapArray = intersectionMapPointIn3D(BHighMapPoint, CHighMapPoint, times);
                    var lowerMapArray = intersectionMapPointIn3D(BMapPoint, CmapPoint, times);
                    castVerticalMapCoords = castVerticalMapCoords.concat(upperMapArray);
                    castVerticalMapCoords = castVerticalMapCoords.concat(lowerMapArray);
                    //A-B-B1；B-B1-A1；
                    for (var j = 0; j < times; j++) {

                        castVerticalMapSequence.push([j + baseindex, j + times + 1 + baseindex, j + times + 1 + 1 + baseindex]);
                        castVerticalMapSequence.push([j + baseindex, j + times + 1 + 1 + baseindex, j + 1 + baseindex])
                    }

                }
                var mapCoordPlus = castMapCoords.length;
                castMapCoords = castMapCoords.concat(castVerticalMapCoords);
                for (var i = 0; i < castVerticalMapSequence.length; i++) {
                    castMapSequence.push(castVerticalMapSequence[i][0] + mapCoordPlus);
                    castMapSequence.push(castVerticalMapSequence[i][1] + mapCoordPlus);
                    castMapSequence.push(castVerticalMapSequence[i][2] + mapCoordPlus);
                }

                var videoCoordsPlus = castVideoCoords.length;
                castVideoCoords = castVideoCoords.concat(castVerticalVideoCoords);
                for (var i = 0; i < castVerticalVideoSequence.length; i++) {
                    castVideoSequence.push(castVerticalVideoSequence[i][0] + videoCoordsPlus);
                    castVideoSequence.push(castVerticalVideoSequence[i][1] + videoCoordsPlus);
                    castVideoSequence.push(castVerticalVideoSequence[i][2] + videoCoordsPlus);
                }
            }
            //融合视频，构造外部渲染器
            document.getElementById("castVideo").addEventListener("click", (event) => {
                reDrawCanvas();
                buildVerticalFace();
                //清除图层
                for (var i = 0; i < map.layers.length; i++) {
                    if (map.layers.getItemAt(i).title == "controlPointLayer") { map.layers.remove(map.layers.getItemAt(i)); }
                }
                delaunayGraphicLayer.graphics.removeAll();
                lineGraphicLayer.graphics.removeAll();
                if (castVideoRenderer != null) {
                    externalRenderers.remove(view, castVideoRenderer);
                    castVideoRenderer = null;
                }
                castVideoRenderer = new yzrVideoCastLayer(view, {
                    videoDomID: "myVideo",
                    castMapSequence: castMapSequence,
                    castMapCoordArray: castMapCoords,
                    castVideoSequence: castVideoSequence,
                    castVideoCoordArray: castVideoCoords,
                });
                externalRenderers.add(view, castVideoRenderer);
            });
            //取消融合
            document.getElementById("canselCastVideo").addEventListener("click", (event) => {
                externalRenderers.remove(view, castVideoRenderer);
                castVideoRenderer = null;
            });
            document.getElementById("exportCastParam").addEventListener("click", (event) => {
                buildVerticalFace();
                var castMapSequenceJSON = JSON.stringify(castMapSequence);
                var castMapCoordsJSON = JSON.stringify(castMapCoords);
                var castVideoSequenceJSON = JSON.stringify(castVideoSequence);
                var castVideoCoordArrayJSON = JSON.stringify(castVideoCoords);
                var videoCastParam = {
                    "castMapSequence": castMapSequenceJSON,
                    "castMapCoords": castMapCoordsJSON,
                    "castVideoSequence": castVideoSequenceJSON,
                    "castVideoCoords": castVideoCoordArrayJSON,
                };
                saveJSON(videoCastParam, "VideoCastParam.json");
            });
            function saveJSON(data, filename) {
                if (!data) {
                    alert('保存的数据为空');
                    return;
                }
                if (!filename)
                    filename = 'json.json'
                if (typeof data === 'object') {
                    data = JSON.stringify(data, undefined, 4)
                }
                var blob = new Blob([data], { type: 'text/json' }),
                    e = document.createEvent('MouseEvents'),
                    a = document.createElement('a')
                a.download = filename
                a.href = window.URL.createObjectURL(blob)
                a.dataset.downloadurl = ['text/json', a.download, a.href].join(':')
                e.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null)
                a.dispatchEvent(e)
            }
            view.ui.add("drawControlPointMenu", "top-right");
            const cam = new Camera({
                heading: 208.9413786712362, // face due east
                tilt: 42.58197056383452, // looking from a bird's eye view
                position: {
                    latitude: 34.242195060923876,
                    longitude: 108.8946213526916,
                    z: 664.5852208156139,
                    spatialReference: { wkid: 4326 }
                }
            });
            view.camera = cam;
            //压平相关代码
            const rings = [
                [  // first ring
                    [12122129.045312526, 4061089.6021141773, 410],
                    [12122227.974202005, 4061223.2493719277, 410],
                    [12122265.933948446, 4061194.2887889855, 410],
                    [12122187.736877317, 4061056.777012161, 410]  // same as first vertex
                ]
            ];
            const rings2 = [
                [  // first ring
                    [12121930.420447621, 4061156.1660324372, 410],
                    [12121935.383919898, 4061227.0830026865, 410],
                    [12122066.878495585, 4061146.3427572837, 410],
                    [12122041.351478789, 4061094.4277423555, 410]  // same as first vertex
                ]
            ];
            const rings3 = [
                [  // first ring
                    [12121970.586487237, 4061052.2946120105, 410],
                    [12122016.245246094, 4061135.4314031377, 410],
                    [12122052.68092715, 4061115.1047974443, 410],
                    [12122004.58788315, 4061028.233492158, 410]  // same as first vertex
                ]
            ];
            const rings4 = [
                [  // first ring
                    [12121862.495567525, 4061096.24932298, 410],
                    [12121914.562826922, 4061191.8575500865, 410],
                    [12121953.846024584, 4061169.9251379133, 410],
                    [12121902.98362092, 4061077.0037124446, 410]  // same as first vertex
                ]
            ];
            const rings5 = [
                [  // first ring
                    [12122163.26776941, 4061080.195181783, 410],
                    [12121927.6810154, 4061210.6210487047, 410],
                    [12122021.72482498, 4061344.664555966, 410],
                    [12122245.48795159, 4061218.056990602, 410]  // same as first vertex
                ]
            ];
            const polygon = new Polygon({
                rings: rings2,
                spatialReference: { wkid: 102100 }
            });
            const polygon2 = new Polygon({
                rings: rings3,
                spatialReference: { wkid: 102100 }
            });
            const polygon3 = new Polygon({
                rings: rings4,
                spatialReference: { wkid: 102100 }
            });
            const polygon4 = new Polygon({
                rings: rings5,
                spatialReference: { wkid: 102100 }
            });

            const polygonGraphic = new Graphic({
                geometry: polygon,
                symbol: fillSymbol
            });
            const graphicsLayer = new GraphicsLayer();
            map.add(graphicsLayer);
            let mymodifications = new SceneModifications([new SceneModification({
                geometry: polygon,
                type: "replace"
            }), new SceneModification({
                geometry: polygon2,
                type: "replace"
            }), new SceneModification({
                geometry: polygon3,
                type: "replace"
            }), new SceneModification({
                geometry: polygon4,
                type: "replace"
            })]
            );
            myIntegratedMeshLayer.modifications = mymodifications;
            map.add(myIntegratedMeshLayer);

        });


</script>

</html>
/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import e from"../core/Error.js";import{i as n}from"../core/lang.js";import{isNumericField as t,numericTypes as l}from"../layers/support/fieldUtils.js";function i(e){const n=null!=e.normalizationField||null!=e.normalizationType,t=null!=e.minValue||null!=e.maxValue,l=!!e.sqlExpression&&e.supportsSQLExpression;return!n&&!t&&!l}function o(e){const n=e.returnDistinct?[...new Set(e.values)]:e.values,t=n.filter((e=>null!=e)).length,l={count:t};return e.supportsNullCount&&(l.nullcount=n.length-t),l}function s(e){const{values:n,useSampleStdDev:t,supportsNullCount:l}=e;let i=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,s=null,r=null,u=null,a=null,c=0;const f=null==e.minValue?-1/0:e.minValue,d=null==e.maxValue?1/0:e.maxValue;for(const e of n)Number.isFinite(e)?e>=f&&e<=d&&(s+=e,i=Math.min(i,e),o=Math.max(o,e),c++):"string"==typeof e&&c++;if(c&&null!=s){r=s/c;let e=0;for(const t of n)Number.isFinite(t)&&t>=f&&t<=d&&(e+=(t-r)**2);a=t?c>1?e/(c-1):0:c>0?e/c:0,u=Math.sqrt(a)}else i=null,o=null;const m={avg:r,count:c,max:o,min:i,stddev:u,sum:s,variance:a};return l&&(m.nullcount=n.length-c),m}function r(e,n){return n?(["avg","stddev","variance"].forEach((n=>{null!=e[n]&&(e[n]=Math.ceil(e[n]))})),e):e}function u(e,n,t,l){let i=null;switch(n){case"log":0!==e&&(i=Math.log(e)*Math.LOG10E);break;case"percent-of-total":Number.isFinite(l)&&0!==l&&(i=e/l*100);break;case"field":Number.isFinite(t)&&0!==t&&(i=e/t);break;case"natural-log":e>0&&(i=Math.log(e));break;case"square-root":e>0&&(i=e**.5)}return i}function a(e){const n=e.field,t=e.normalizationType,l=e.normalizationField;let i;return"log"===t?i="(NOT "+n+" = 0)":"field"===t?i="(NOT "+l+" = 0)":"natural-log"!==t&&"square-root"!==t||(i=`(${n} > 0)`),i}function c(n,t){return new e(n,t)}function f(e,n,t){const l=null!=n?e+" >= "+n:"",i=null!=t?e+" <= "+t:"";let o="";return o=l&&i?p(l,i):l||i,o?"("+o+")":""}function d(e,n,t,l){let i=null;return n?n.name!==e.objectIdField&&-1!==l.indexOf(n.type)||(i=c(t,"'field' should be one of these types: "+l.join(","))):i=c(t,"'field' is not defined in the layer schema"),i}function m(e,n,i){let o;return n?n.name!==e.objectIdField&&t(n)||(o=c(i,"'field' should be one of these numeric types: "+l.join(","))):o=c(i,"'field' is not defined in the layer schema"),o}function p(e,t){let l=n(e)?e:"";return n(t)&&t&&(l=l?"("+l+") AND ("+t+")":t),l}function h(e,n,t){const l=function(e){const n=e.layer;return e.fields.filter((e=>!n.getField(e)))}({layer:e,fields:n});if(l.length)return c(t,"Unknown fields: "+l.join(", ")+". You can only use fields defined in the layer schema");const i=function(e){const n=e.layer;return e.fields.filter((e=>{const t=n.getFieldUsageInfo(e);return!t||!t.supportsStatistics}))}({layer:e,fields:n});return i.length?c(t,"Unsupported fields: "+i.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}export{f as a,m as b,d as c,o as d,s as e,u as f,a as g,i,p as m,r as p,h as v};

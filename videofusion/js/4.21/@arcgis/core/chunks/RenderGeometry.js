/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{d as t,b as e,i as s}from"../core/lang.js";import{g as n,a as r}from"./unitConversionUtils.js";import{L as i}from"./Logger.js";import{f as a}from"./ScreenSpacePass.js";import{l as o}from"./arcadeOnDemand.js";import{g as f}from"../core/Accessor.js";import{e as u}from"./mat4.js";import{c as h,I as c}from"./mat4f64.js";import{t as l}from"./mathUtils.js";import{a as m}from"./vec4f64.js";import{b as d}from"./mathUtils2.js";import{a as p}from"./geometryDataUtils.js";import{b as g}from"./Intersector.js";import{a as _,r as x}from"./verticalOffsetUtils.js";const U=i.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function I(t){const e=t&&t.expression;if("string"==typeof e){const t=C(e);if(null!=t)return{cachedResult:t}}return null}async function E(t,e,s){const n=t&&t.expression;if("string"!=typeof n)return null;const r=C(n);if(null!=r)return{cachedResult:r};const i=await o(),a=i.arcadeUtils,f=a.createSyntaxTree(n);return a.dependsOnView(f)?(null!=s&&s.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:a.createFunction(f),context:a.createExecContext(null,{sr:e}),modules:i}}}function v(t,e,s){return t.arcadeUtils.createFeature(e.attributes,e.geometry,s)}function O(t,e){if(null!=t&&!b(t)){if(!e||!t.arcade)return void U.errorOncePerTick("Arcade support required but not provided");const s=e;s._geometry&&(s._geometry=a(s._geometry)),t.arcade.modules.arcadeUtils.updateExecContext(t.arcade.context,e)}}function T(t,e=!1){let s=t&&t.featureExpressionInfo;const n=s&&s.expression;return e||"0"===n||(s=null),s}const y={cachedResult:0};function b(t){return null!=t.cachedResult}function C(t){return"0"===t?0:null}class R{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(t){this._unit=t,this._metersPerElevationInfoUnit=n(t)}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(t){this._meterUnitOffset=t,this._renderUnitOffset=0}set offsetElevationInfoUnits(t){this._meterUnitOffset=t*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(t){this._renderUnitOffset+=t}geometryZWithOffset(t,e){const s=this.calculateOffsetRenderUnits(e);return null!=this.featureExpressionInfoContext?s:t+s}calculateOffsetRenderUnits(t){let e=this._meterUnitOffset;const s=this.featureExpressionInfoContext;return null!=s&&(e+=function(t){if(null!=t){if(b(t))return t.cachedResult;const e=t.arcade;let s=t.arcade.modules.arcadeUtils.executeFunction(e.func,e.context);return"number"!=typeof s&&(t.cachedResult=0,s=0),s}return 0}(s)*this._metersPerElevationInfoUnit),e/t.unitInMeters+this._renderUnitOffset}setFromElevationInfo(e){this.mode=e.mode,this.unit=r(e.unit)?e.unit:"meters",this.offsetElevationInfoUnits=t(e.offset,0)}updateFeatureExpressionInfoContext(t,n,r){if(e(t))return void(this._featureExpressionInfoContext=null);const i=t&&t.arcade;var a;i&&s(n)&&s(r)?(this._featureExpressionInfoContext={cachedResult:(a=t).cachedResult,arcade:a.arcade?{func:a.arcade.func,context:a.arcade.modules.arcadeUtils.createExecContext(null,{sr:a.arcade.context.spatialReference}),modules:a.arcade.modules}:null},O(this._featureExpressionInfoContext,v(i.modules,n,r))):this._featureExpressionInfoContext=t}static fromElevationInfo(t){const e=new R;return s(t)&&e.setFromElevationInfo(t),e}}class S{constructor(t,e,s=null,n=null,r=f(),i=null,a=null,o=!1){this.data=t,this.material=e,this.layerUid=s,this.graphicUid=n,this.id=r,this.boundingInfo=i,this.calculateShaderTransformation=a,this.castShadow=o,this.boundingSphere=m(),this.instanceParameters={highlights:null,occludees:null,visible:!0},this._transformation=h(),this._shaderTransformationDirty=!0}get transformation(){return this._transformation}updateTransformation(t){t(this._transformation),this._shaderTransformationDirty=!0,this.computeBoundingSphere(this._transformation,this.boundingSphere)}shaderTransformationChanged(){this._shaderTransformationDirty=!0}computeBoundingSphere(t,s,n=d(t)){e(this.boundingInfo)||(l(s,this.boundingInfo.getCenter(),t),s[3]=this.boundingInfo.getBSRadius()*n)}get hasShaderTransformation(){return s(this.calculateShaderTransformation)}get primitiveType(){return this.data.primitiveType}getShaderTransformation(){return e(this.calculateShaderTransformation)?t(this.transformation,c):(this._shaderTransformationDirty&&(this._shaderTransformation||(this._shaderTransformation=h()),u(this._shaderTransformation,this.calculateShaderTransformation(t(this.transformation,c))),this._shaderTransformationDirty=!1),this._shaderTransformation)}computeAttachmentOrigin(t){if(this.material.computeAttachmentOrigin)return!!this.material.computeAttachmentOrigin(this,t)&&(s(this._transformation)&&l(t,t,this._transformation),!0);const e=this.indices.get("position"),n=this.vertexAttributes.get("position");return!!p(n,e,t)&&(s(this._transformation)&&l(t,t,this._transformation),!0)}get indices(){return this.data.indices}get vertexAttributes(){return this.data.vertexAttributes}addHighlight(){const t=new g(0),e=this.instanceParameters;return e.highlights=_(e.highlights,t),t}removeHighlight(t){const e=this.instanceParameters;e.highlights=x(e.highlights,t)}}export{R as E,S as R,E as a,I as b,v as c,T as e,O as s,y as z};

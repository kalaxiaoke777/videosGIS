/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{L as e}from"./Logger.js";import{i as t,u as s,b as i}from"../core/lang.js";import{d as r}from"./screenUtils.js";import{c as a}from"./vec2.js";import{e as o,s as n,d as l,f as p,g as c,k as u,l as d,w as h,b as f}from"./mathUtils.js";import{c as m,d as g,f as v,a as P}from"./lineSegment.js";import{c as x,f as b,s as C,n as y}from"./plane.js";import{a as E}from"./BufferView.js";import{c as w}from"./geometryDataUtils.js";import{S,T as j,g as O,r as _,q as T,B as q,p as R,a as U,b as A,c as B,P as L,D as z,h as V,F as H,$ as I,a0 as D,a7 as M,J as N,a2 as F,L as $,a9 as W,ao as G,aa as X,a8 as k}from"./OutputDepth.glsl.js";import{c as J}from"./Util.js";import{V as K,c as Q}from"./VertexColor.glsl.js";import{a as Y,b as Z,D as ee}from"./ColorMaterial.js";import{i as te}from"./verticalOffsetUtils.js";import{_ as se}from"./tslib.es6.js";import{L as ie}from"./lineUtils.js";import{s as re,m as ae,d as oe,c as ne}from"./VertexArrayObject.js";var le=Object.freeze({__proto__:null,build:function(e){const t=new S;return t.include(j,{linearDepth:!1}),t.include(K,e),t.include(ie,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),t.vertex.code.add(O`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`),e.stippleEnabled&&(t.attributes.add("auxpos1","vec3"),t.vertex.uniforms.add("ndcToPixel","vec2"),t.vertex.code.add(O`
    vec4 vpos2 = transformPosition(proj, view, auxpos1);
    float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);

    stipplePatternUv = lineSegmentPixelSize * stipplePatternPixelSizeInv;
    ${e.stippleIntegerRepeatsEnabled?"stipplePatternUv = floor(stipplePatternUv + 0.5);":""}

    // Cancel out perspective correct interpolation because we want this length the really represent
    // the screen distance
    stipplePatternUv *= gl_Position.w;
    `)),t.vertex.code.add(O`}`),4===e.output&&t.include(_),t.include(T,e),t.fragment.uniforms.add("constantColor","vec4").add("alphaCoverage","float"),t.fragment.code.add(O`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${e.attributeColor?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${O.float(q)}) {
      discard;
    }

    ${0===e.output?O`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${4===e.output?O`outputHighlight();`:""}
  }
  `),t}});class pe extends B{constructor(e,t,s){super(e,t,s),this.stipplePattern=null,this.stippleTextureBind=null,this.stippleTextureRepository=e.stippleTextureRepository}initializeProgram(e){const t=pe.shader.get(),s=this.configuration,i=t.build({output:s.output,attributeColor:s.vertexColors,slicePlaneEnabled:s.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,draped:!1,stippleEnabled:s.stippleEnabled,stippleOffColorEnabled:s.stippleOffColorEnabled,stippleUVMaxEnabled:!1,stippleIntegerRepeatsEnabled:s.stippleIntegerRepeatsEnabled});return new L(e.rctx,i,z)}dispose(){super.dispose(),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null}bindPass(e,i){if(V(this.program,i.camera.projectionMatrix),this.stipplePattern!==e.stipplePattern){const t=e.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,t),this.stipplePattern=t}if(this.configuration.stippleEnabled){const{pixelSize:e,sdfNormalizer:s}=t(this.stippleTextureBind)?this.stippleTextureBind(this.program):{pixelSize:1,sdfNormalizer:1};this.program.setUniform1f("stipplePatternSDFNormalizer",s),this.program.setUniform1i("stipplePatternTexture",0),this.program.setUniform1f("stipplePatternPixelSizeInv",1/(e*i.camera.pixelRatio)),this.program.setUniform2f("ndcToPixel",i.camera.fullViewport[2]/2,i.camera.fullViewport[3]/2)}if(this.program.setUniform4fv("constantColor",e.color),this.program.setUniform1f("alphaCoverage",Math.min(1,e.width*i.camera.pixelRatio)),this.configuration.stippleOffColorEnabled){const t=s(e.stippleOffColor);this.program.setUniform4f("stippleOffColor",t[0],t[1],t[2],t.length>3?t[3]:1)}4===this.configuration.output&&H(this.program,i)}bindDraw(e){I(this.program,e),D(this.program,this.configuration,e),this.program.rebindTextures()}initializePipeline(){const e=this.configuration,t=re(770,1,771,771),s=(t,s=null,i=null)=>ae({blending:s,depthTest:M,depthWrite:i,colorWrite:oe,stencilWrite:e.sceneHasOcludees?N:null,stencilTest:e.sceneHasOcludees?t?F:$:null});return 0===e.output?(this._occludeePipelineState=s(!0,e.transparent||e.stippleEnabled?t:null,ne),s(!1,e.transparent||e.stippleEnabled?t:null,ne)):s(!1)}get primitiveType(){return 1}getPipelineState(e){return e?this._occludeePipelineState:this.pipeline}}pe.shader=new U(le,(()=>Promise.resolve().then((function(){return le}))));class ce extends A{constructor(){super(...arguments),this.output=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.transparent=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleIntegerRepeatsEnabled=!1,this.sceneHasOcludees=!1}}se([R({count:8})],ce.prototype,"output",void 0),se([R()],ce.prototype,"slicePlaneEnabled",void 0),se([R()],ce.prototype,"vertexColors",void 0),se([R()],ce.prototype,"transparent",void 0),se([R()],ce.prototype,"draped",void 0),se([R()],ce.prototype,"stippleEnabled",void 0),se([R()],ce.prototype,"stippleOffColorEnabled",void 0),se([R()],ce.prototype,"stippleIntegerRepeatsEnabled",void 0),se([R()],ce.prototype,"sceneHasOcludees",void 0);const ue=e.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");class de extends W{constructor(e){super(e,me),this.techniqueConfig=new ce}getTechniqueConfig(e){this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.transparent=this.params.color[3]<1||this.params.width<1,this.techniqueConfig.draped=!1;const s=t(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=s,this.techniqueConfig.stippleOffColorEnabled=s&&t(this.params.stippleOffColor),this.techniqueConfig.stippleIntegerRepeatsEnabled=s&&this.params.stippleIntegerRepeats,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig}getPassParameters(){return this.params}intersect(e,t,s,i,r,a,o,n,l){l?G(e,i,a,1,o):this.intersectLineGeometry(e,t,s,i,o)}intersectLineGeometry(e,t,s,i,r){if(!i.options.selectionMode||te(t))return;if(!J(s))return void ue.error("intersection assumes a translation-only matrix");const f=e.vertexAttributes.get("position").data,m=i.camera,x=je;a(x,i.point);o(Oe[0],x[0]-2,x[1]+2,0),o(Oe[1],x[0]+2,x[1]+2,0),o(Oe[2],x[0]+2,x[1]-2,0),o(Oe[3],x[0]-2,x[1]-2,0);for(let e=0;e<4;e++)if(!m.unprojectFromRenderScreen(Oe[e],_e[e]))return;b(m.eye,_e[0],_e[1],Te),b(m.eye,_e[1],_e[2],qe),b(m.eye,_e[2],_e[3],Re),b(m.eye,_e[3],_e[0],Ue);let E=Number.MAX_VALUE;for(let e=0;e<f.length-5;e+=3){if(ge[0]=f[e]+s[12],ge[1]=f[e+1]+s[13],ge[2]=f[e+2]+s[14],ve[0]=f[e+3]+s[12],ve[1]=f[e+4]+s[13],ve[2]=f[e+5]+s[14],C(Te,ge)<0&&C(Te,ve)<0||C(qe,ge)<0&&C(qe,ve)<0||C(Re,ge)<0&&C(Re,ve)<0||C(Ue,ge)<0&&C(Ue,ve)<0)continue;if(m.projectToRenderScreen(ge,be),m.projectToRenderScreen(ve,Ce),be[2]<0&&Ce[2]>0){n(Pe,ge,ve);const e=m.frustum,t=-C(e[4],ge)/l(Pe,y(e[4]));p(Pe,Pe,t),c(ge,ge,Pe),m.projectToRenderScreen(ge,be)}else if(be[2]>0&&Ce[2]<0){n(Pe,ve,ge);const e=m.frustum,t=-C(e[4],ve)/l(Pe,y(e[4]));p(Pe,Pe,t),c(ve,ve,Pe),m.projectToRenderScreen(ve,Ce)}else if(be[2]<0&&Ce[2]<0)continue;be[2]=0,Ce[2]=0;const t=g(v(be,Ce,we),x);t<E&&(E=t,u(ye,ge),u(Ee,ve))}const w=i.rayBeginPoint,S=i.rayEndPoint;if(E<4){let e=Number.MAX_VALUE;if(P(v(ye,Ee,we),v(w,S,Se),xe)){n(xe,xe,w);const t=d(xe);p(xe,xe,1/t),e=t/h(w,S)}r(e,xe)}}computeAttachmentOrigin(e,t){const s=e.vertexAttributes;if(!s)return!1;const i=s.get("position");return w(i,null,!1,t)}createBufferWriter(){const e=this.params.vertexColors?Y:Z;return i(this.params.stipplePattern)?new ee(e):new fe(e.clone().vec3f("auxpos1"))}getGLMaterial(e){return 0===e.output||4===e.output?new he(e):void 0}}class he extends X{constructor(e){super(e),this.updateParameters()}updateParameters(){this._technique=this._techniqueRep.releaseAndAcquire(pe,this._material.getTechniqueConfig(this._output),this._technique)}beginSlot(e){return 3===e||23===e}_updateOccludeeState(e){e.hasOccludees!==this._material.params.sceneHasOcludees&&(this._material.setParameterValues({sceneHasOcludees:e.hasOccludees}),this.updateParameters())}ensureParameters(e){0===this._output&&this._updateOccludeeState(e)}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}getPipelineState(e,t){return this._technique.getPipelineState(t)}}class fe{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,s,i){Q(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,s,i),this.writeAuxpos1(e,t,s,i)}writeAuxpos1(e,t,s,i){const r=s.getField("auxpos1",E),a=t.indices.get("position"),o=t.vertexAttributes.get("position").data,n=e.transformation,l=r.typedBufferStride,p=r.typedBuffer;i*=l;for(let e=0;e<a.length;e+=2){const t=3*a[e],s=o[t],r=o[t+1],c=o[t+2],u=n[0]*s+n[4]*r+n[8]*c+n[12],d=n[1]*s+n[5]*r+n[9]*c+n[13],h=n[2]*s+n[6]*r+n[10]*c+n[14];for(let e=0;e<2;++e)p[i]=u,p[i+1]=d,p[i+2]=h,i+=l}}}const me={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,sceneHasOcludees:!1,...k},ge=f(),ve=f(),Pe=f(),xe=f(),be=r(),Ce=r(),ye=f(),Ee=f(),we=m(),Se=m(),je=f(),Oe=[r(),r(),r(),r()],_e=[f(),f(),f(),f()],Te=x(),qe=x(),Re=x(),Ue=x();export{de as N};

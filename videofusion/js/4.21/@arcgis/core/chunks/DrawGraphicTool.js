/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../Graphic.js";import{l as r,clone as i,b as a,j as o,i as s}from"../core/lang.js";import{E as n}from"./Evented.js";import{HandleOwnerMixin as l}from"../core/HandleOwner.js";import{m as p}from"./handleUtils.js";import{property as c}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import"./Logger.js";import{subclass as h}from"../core/accessorSupport/decorators/subclass.js";import u from"../layers/GraphicsLayer.js";import"../geometry.js";import{e as d}from"./arrayUtils.js";import{a as y}from"./unitUtils.js";import m from"../geometry/Circle.js";import{simplify as g,distance as f}from"../geometry/geometryEngine.js";import x,{u as v,i as w,h as O}from"../geometry/Polygon.js";import{j as M}from"../geometry/SpatialReference.js";import{m as V,c as _}from"./surfaceCoordinateSystems.js";import b from"../geometry/Multipoint.js";import G from"../geometry/Polyline.js";import j from"../geometry/Point.js";import{I as R}from"./InteractiveToolBase.js";function T(e,t){const r=new j({x:e[0],y:e[1],spatialReference:t});return e.length>2&&(r.z=e[2]),r}function C(e,t,r){const i=new G({paths:e,spatialReference:t});return r&&v(i),i}function U(e,t,r,a=!0){const o=i(e);o.forEach((e=>{const t=e[0],r=e[e.length-1];d(t,r)&&1!==e.length||e.push(e[0])}));let s=new x({rings:o,spatialReference:t});return s.rings.forEach((e=>{w(e,!1,!1)||e.reverse()})),r&&v(s),a&&s.isSelfIntersecting&&M(t)&&(s=g(s)),s}function S(e,t,i){const a=t.mapToLocalMultiple(e),o=[],s={x:a[0].x,y:a[0].y},n=a[1].x,l=a[1].y,p=Math.round(n-s.x),c=Math.round(l-s.y),h=Math.max(Math.abs(p),Math.abs(c));if(i){const e={x:s.x+h,y:s.y+h},t={x:s.x-h,y:s.y-h};o.push(V(e.x,t.y),V(t.x,t.y),V(t.x,e.y),V(e.x,e.y))}else{const e={x:p>0?s.x+h:s.x-h,y:c>0?s.y+h:s.y-h};o.push(V(s.x,s.y),V(e.x,s.y),V(e.x,e.y),V(s.x,e.y))}return U([r(o.map((e=>t.localToMap(e))))],t.spatialReference,t.doUnnormalization,!0)}function L(e,t,r,i){const o=t.mapToLocalMultiple(e);let s=null,n=null;if(r)s=o[0],n=o[1];else{const e=o[0],t=o[1],r=Math.round(t.x-e.x),i=Math.round(t.y-e.y),a=Math.max(Math.abs(r),Math.abs(i));s=V(r>0?e.x+a/2:e.x-a/2,i>0?e.y+a/2:e.y-a/2),n=V(Math.abs(r)>Math.abs(i)?s.x-a/2:s.x,Math.abs(r)>Math.abs(i)?s.y:s.y-a/2)}const l=t.localToMap(s),p=t.localToMap(n);if(a(l)||a(p))return null;t.doUnnormalization&&O([[l,p]],t.spatialReference);const c=T(l,t.spatialReference),h=T(p,t.spatialReference),u=y(t.spatialReference);let d=0;if(M(t.spatialReference))d=u*f(c,h,null);else{const e=s.x-n.x,t=s.y-n.y;d=u*Math.sqrt(e*e+t*t)*(i||1)}const g=new m({center:c,radius:d,radiusUnit:"meters",spatialReference:t.spatialReference});return U(g.rings,g.spatialReference,!1)}let z=class extends(l(n.EventedMixin(R))){constructor(e){super(e),this._graphic=null,this.defaultZ=0,this.geometryType=null,this.hasZ=!0,this.mode=null,this.snappingManager=null,this.snapToScene=!1}initialize(){this.internalGraphicsLayer=new u({listMode:"hide",internal:!0}),this.view.map.layers.add(this.internalGraphicsLayer),this.drawOperation=this.makeDrawOperation(),this.handles.add([this.drawOperation.on("vertex-add",(e=>this.onVertexAdd(e))),this.drawOperation.on("vertex-remove",(e=>this.onVertexRemove(e))),this.drawOperation.on("vertex-update",(e=>this.onVertexUpdate(e))),this.drawOperation.on("cursor-update",(e=>this.onCursorUpdate(e))),this.drawOperation.on("complete",(e=>this.onComplete(e)))]),this.complete()}destroy(){this.drawOperation=o(this.drawOperation),this._destroyAllVisualisations(),this.view.map.remove(this.internalGraphicsLayer),this.internalGraphicsLayer=o(this.internalGraphicsLayer),this._set("view",null)}get canRedo(){return this.drawOperation.canRedo}get canUndo(){return this.drawOperation.canUndo}set centered(e){this._set("centered",e),this._updateGraphic()}set enabled(e){this.drawOperation.interactive=e,this._set("enabled",e)}set forceUniformSize(e){this._set("forceUniformSize",e),this._updateGraphic()}get graphic(){return this._graphic}set graphicSymbol(e){this._set("graphicSymbol",e),s(this._graphic)&&(this._graphic.symbol=e)}get updating(){var e,t;return null!=(e=null==(t=this.drawOperation)?void 0:t.updating)&&e}completeCreateOperation(){this.drawOperation.complete()}onInputEvent(e){this.drawOperation.onInputEvent(e)}redo(){this.drawOperation.redo()}reset(){}undo(){this.drawOperation.undo()}_createGraphic(e){this._graphic=new t({geometry:e,symbol:this.graphicSymbol}),this.internalGraphicsLayer.add(this._graphic),this.handles.add(this.initializeGraphic(this._graphic)),this.notifyChange("graphic"),this.handles.add(p((()=>{s(this._graphic)&&(this.internalGraphicsLayer.remove(this._graphic),this._graphic=o(this._graphic))})),k)}_destroyAllVisualisations(){this.handles.remove(P.outline),this.handles.remove(P.regularVertices),this.handles.remove(P.activeVertex),this.handles.remove(k)}_getCreateOperationGeometry(e={operationComplete:!1}){if(null==this.drawOperation||0===this.drawOperation.numVertices)return null;const t=this.drawOperation.stagedVertex,i=this.drawOperation.committedVertices,a=i.slice();s(t)&&a.push(this.drawOperation.coordinateHelper.pointToArray(t));const o=s(t)?this.drawOperation.coordinateHelper.pointToArray(t):i.splice(-1)[0],n={regularVertices:null,activeVertex:null,full:null,outline:null},l=a.length,p=this.drawOperation.spatialReference,c="3d"===this.view.type&&"global"===this.view.viewingMode;switch(this.geometryType){case"point":n.regularVertices=i,n.activeVertex=o,n.full=this.drawOperation.coordinateHelper.arrayToPoint(a[0]);break;case"multipoint":n.regularVertices=i,n.activeVertex=o,l>0&&(n.full=function(e,t){return new b({points:e,spatialReference:t})}(a,p));break;case"polyline":n.regularVertices=i,n.activeVertex=o,l>0&&(n.full=C([a],p,c));break;case"polygon":n.regularVertices=i,n.activeVertex=o,l>0&&(n.full=U([a],p,c,!0));break;case"circle":if(l>0){const t=_(this.view,a[0]);if(1===l&&e.operationComplete){const e=a[0],r=t.makeMapPoint(e[0]+E*this.view.resolution,e[1]);n.full=L([e,r],t,!0)}else 2===l&&(n.full=this.forceUniformSize?L(a,t,this.centered):function(e,t,i){const a=t.mapToLocalMultiple(e),o=a[0],s=a[1],n=Math.round(s.x-o.x),l=Math.round(s.y-o.y),p=V(i?o.x:o.x+n/2,i?o.y:o.y+l/2),c=i?n:n/2,h=i?l:l/2,u=[],d=2*Math.PI/60;for(let e=0;e<60;e++){const t=Math.cos(e*d),r=Math.sin(e*d),i=V(c*t+p.x,h*r+p.y);u.push(i)}return u.push(u[0]),U([r(u.map((e=>t.localToMap(e))))],t.spatialReference,t.doUnnormalization,!1)}(a,t,this.centered))}break;case"rectangle":if(l>0){const t=_(this.view,a[0]);if(1===l&&e.operationComplete){const e=a[0],r=t.makeMapPoint(e[0]+E*this.view.resolution,e[1]);n.full=S([e,r],t,!0)}else 2===l&&(n.full=this.forceUniformSize?S(a,t,this.centered):function(e,t,i){let a=t.mapToLocalMultiple(e);if(1===a.length){const e=48,t=a[0];a=[V(t.x-e,t.y+e),V(t.x+e,t.y-e),V(t.x+e,t.y-e),V(t.x-e,t.y+e)]}const o=[],s={x:a[0].x,y:a[0].y},n={x:a[1].x,y:a[1].y};if(i){const e=Math.round(n.x-s.x),t=Math.round(n.y-s.y);o.push(V(s.x-e,s.y-t),V(n.x,s.y-t),V(n.x,n.y),V(s.x-e,n.y))}else o.push(V(s.x,s.y),V(n.x,s.y),V(n.x,n.y),V(s.x,n.y));return U([r(o.map((e=>t.localToMap(e))))],t.spatialReference,t.doUnnormalization,!0)}(a,t,this.centered))}break;default:return null}switch(this.geometryType){case"point":case"multipoint":break;case"polyline":case"polygon":l>1&&(n.outline=C([a],p,c));break;case"circle":case"rectangle":s(n.full)&&"polygon"===n.full.type&&(n.outline=U(n.full.rings,p,c))}return n}initializeGraphic(e){return null}onComplete(e){this._updateGraphic();let r=null;if(this.drawOperation.isCompleted){const e=this._getCreateOperationGeometry({operationComplete:!0});s(e)&&(r=new t({geometry:e.full,symbol:this.graphicSymbol,sourceLayer:this.internalGraphicsLayer,...this.graphicProperties}))}this.emit("complete",{graphic:r,...e})}onCursorUpdate(e){this._updateGraphic(),this.emit("cursor-update",e)}onDeactivate(){this.drawOperation.isCompleted||this.drawOperation.cancel()}onVertexAdd(e){this._updateGraphic(),this.emit("vertex-add",e)}onVertexRemove(e){this._updateGraphic(),this.emit("vertex-remove",e)}onVertexUpdate(e){this._updateGraphic(),this.emit("vertex-update",e)}_updateGraphic(){const e=this._getCreateOperationGeometry();a(e)?this._destroyAllVisualisations():(s(e.outline)?this.handles.add(this.onOutlineChanged(e.outline),P.outline):this.handles.remove(P.outline),s(e.regularVertices)?this.handles.add(this.onRegularVerticesChanged(e.regularVertices),P.regularVertices):this.handles.remove(P.regularVertices),s(e.activeVertex)?this.handles.add(this.onActiveVertexChanged(e.activeVertex),P.activeVertex):this.handles.remove(P.activeVertex),s(e.full)?a(this._graphic)?this._createGraphic(e.full):this._graphic.geometry=e.full:this.handles.remove(k))}};e([c({value:!0})],z.prototype,"centered",null),e([c({nonNullable:!0})],z.prototype,"defaultZ",void 0),e([c()],z.prototype,"drawOperation",void 0),e([c({value:!0})],z.prototype,"enabled",null),e([c({value:!0})],z.prototype,"forceUniformSize",null),e([c({constructOnly:!0})],z.prototype,"geometryType",void 0),e([c()],z.prototype,"graphic",null),e([c({constructOnly:!0})],z.prototype,"graphicProperties",void 0),e([c()],z.prototype,"graphicSymbol",null),e([c({constructOnly:!0})],z.prototype,"hasZ",void 0),e([c({constructOnly:!0})],z.prototype,"mode",void 0),e([c()],z.prototype,"snappingManager",void 0),e([c()],z.prototype,"snapToScene",void 0),e([c({readOnly:!0})],z.prototype,"type",void 0),e([c({readOnly:!0})],z.prototype,"updating",null),e([c({constructOnly:!0,nonNullable:!0})],z.prototype,"view",void 0),z=e([h("esri.views.draw.DrawGraphicTool")],z);const k="create-operation-graphic",P={outline:"outline-visual",regularVertices:"regular-vertices-visual",activeVertex:"active-vertex-visual"};function A(e){switch(e){case"point":case"polyline":case"polygon":case"multipoint":return e;case"circle":case"rectangle":return"segment";default:return null}}const E=48;export{z as D,A as g};

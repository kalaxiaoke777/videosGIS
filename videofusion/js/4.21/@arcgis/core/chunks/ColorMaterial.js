/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{s as t,a as e,n,f as a,g as r,d as o,e as s,k as i,t as l,b as c}from"./mathUtils.js";import{f as u,c as h,a as p}from"./vec3f32.js";import{c as f,q as d,j as m}from"./plane.js";import{w as g}from"./ray.js";import{ab as y,S as v,T as w,O as b,g as A,q as x,C as P,R as z,E as M,r as C,B as F,p as G,a as T,b as U,c as O,P as q,D as _,h as E,F as D,W as S,$ as j,a0 as I,G as H,H as $,I as B,J as L,a2 as V,L as W,ad as k,a9 as N,ah as R,ai as J,aa as K,a8 as Q}from"./OutputDepth.glsl.js";import{g as X}from"./geometryDataUtils.js";import{a as Y}from"./Util.js";import{n as Z}from"./InterleavedLayout.js";import{c as tt,V as et}from"./VertexColor.glsl.js";import{_ as nt}from"./tslib.es6.js";import{m as at,e as rt,c as ot,d as st}from"./VertexArrayObject.js";var it;!function(t){t.length=function(t,e){const n=t[e],a=t[e+1],r=t[e+2];return Math.sqrt(n*n+a*a+r*r)},t.normalize=function(t,e){const n=t[e],a=t[e+1],r=t[e+2],o=1/Math.sqrt(n*n+a*a+r*r);t[e]*=o,t[e+1]*=o,t[e+2]*=o},t.scale=function(t,e,n){t[e]*=n,t[e+1]*=n,t[e+2]*=n},t.add=function(t,e,n,a,r,o=e){(r=r||t)[o]=t[e]+n[a],r[o+1]=t[e+1]+n[a+1],r[o+2]=t[e+2]+n[a+2]},t.subtract=function(t,e,n,a,r,o=e){(r=r||t)[o]=t[e]-n[a],r[o+1]=t[e+1]-n[a+1],r[o+2]=t[e+2]-n[a+2]}}(it||(it={}));const lt=it;var ct,ut,ht,pt;!function(t){const e=.5,n=[[-e,-e,e],[e,-e,e],[e,e,e],[-e,e,e],[-e,-e,-e],[e,-e,-e],[e,e,-e],[-e,e,-e]],a=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],r=[0,0,1,0,1,1,0,1],o=new Uint16Array([0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5]),s=new Uint16Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)s[6*t+e]=t;const i=new Uint16Array(36);for(let t=0;t<6;t++)i[6*t+0]=0,i[6*t+1]=1,i[6*t+2]=2,i[6*t+3]=2,i[6*t+4]=3,i[6*t+5]=0;t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(24);for(let a=0;a<8;a++)e[3*a]=n[a][0]*t[0],e[3*a+1]=n[a][1]*t[1],e[3*a+2]=n[a][2]*t[2];return new y([["position",{size:3,data:e,exclusive:!0}],["normal",{size:3,data:a}],["uv0",{size:2,data:r}]],[["position",o],["normal",s],["uv0",i]])}}(ct||(ct={})),function(t){const e=.5,n=[[-e,0,-e],[e,0,-e],[e,0,e],[-e,0,e],[0,-e,0],[0,e,0]],a=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],r=new Uint16Array([5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0]),o=new Uint16Array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]);t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(18);for(let a=0;a<6;a++)e[3*a]=n[a][0]*t[0],e[3*a+1]=n[a][1]*t[1],e[3*a+2]=n[a][2]*t[2];return new y([["position",{size:3,data:e,exclusive:!0}],["normal",{size:3,data:a}]],[["position",r],["normal",o]])}}(ut||(ut={})),function(a){const r=.5,o=u(-r,0,-r),s=u(r,0,-r),i=u(0,0,r),l=u(0,.5,0),c=h(),p=h(),f=h(),d=h(),m=h();t(c,o,l),t(p,o,s),e(f,c,p),n(f,f),t(c,s,l),t(p,s,i),e(d,c,p),n(d,d),t(c,i,l),t(p,i,o),e(m,c,p),n(m,m);const g=[o,s,i,l],v=[0,-1,0,f[0],f[1],f[2],d[0],d[1],d[2],m[0],m[1],m[2]],w=[0,1,2,3,1,0,3,2,1,3,0,2],b=[0,0,0,1,1,1,2,2,2,3,3,3];a.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(12);for(let n=0;n<4;n++)e[3*n]=g[n][0]*t[0],e[3*n+1]=g[n][1]*t[1],e[3*n+2]=g[n][2]*t[2];return new y([["position",{size:3,data:e,exclusive:!0}],["normal",{size:3,data:v}]],[["position",new Uint16Array(w)],["normal",new Uint16Array(b)]])}}(ht||(ht={})),function(v){v.createBoxGeometry=ct.createGeometry,v.createDiamondGeometry=ut.createGeometry,v.createTetrahedronGeometry=ht.createGeometry,v.createSphereGeometry=function(t,e,n,a={uv:!0}){const r=-Math.PI,o=2*Math.PI,s=-Math.PI/2,i=Math.PI,l=Math.max(3,Math.floor(e)),c=Math.max(2,Math.floor(n)),u=(l+1)*(c+1),h=new Float32Array(3*u),p=new Float32Array(3*u),f=new Float32Array(2*u),d=[];let m=0;for(let e=0;e<=c;e++){const n=[],a=e/c,u=s+a*i,g=Math.cos(u);for(let e=0;e<=l;e++){const s=e/l,i=r+s*o,c=Math.cos(i)*g,d=Math.sin(u),y=-Math.sin(i)*g;h[3*m]=c*t,h[3*m+1]=d*t,h[3*m+2]=y*t,p[3*m]=c,p[3*m+1]=d,p[3*m+2]=y,f[2*m]=s,f[2*m+1]=a,n.push(m),++m}d.push(n)}const g=new Uint32Array(2*l*(c-1)*3);m=0;for(let t=0;t<c;t++)for(let e=0;e<l;e++){const n=d[t][e],a=d[t][e+1],r=d[t+1][e+1],o=d[t+1][e];0===t?(g[m++]=n,g[m++]=r,g[m++]=o):t===c-1?(g[m++]=n,g[m++]=a,g[m++]=r):(g[m++]=n,g[m++]=a,g[m++]=r,g[m++]=r,g[m++]=o,g[m++]=n)}const v=[["position",g],["normal",g]],w=[["position",{size:3,data:h,exclusive:!0}],["normal",{size:3,data:p,exclusive:!0}]];return a.uv&&(w.push(["uv0",{size:2,data:f,exclusive:!0}]),v.push(["uv0",g])),a.offset&&(v[0][0]="offset",w[0][0]="offset",v.push(["position",new Uint32Array(g.length)]),w.push(["position",{size:3,data:Float64Array.from(a.offset),exclusive:!0}])),new y(w,v)},v.createPolySphereGeometry=function(t,e,n){const a=t;let r,o;if(n)r=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],o=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const t=a*(1+Math.sqrt(5))/2;r=[-a,t,0,a,t,0,-a,-t,0,a,-t,0,0,-a,t,0,a,t,0,-a,-t,0,a,-t,t,0,-a,t,0,a,-t,0,-a,-t,0,a],o=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let e=0;e<r.length;e+=3)lt.scale(r,e,t/lt.length(r,e));let s={};function i(e,n){e>n&&([e,n]=[n,e]);const a=e.toString()+"."+n.toString();if(s[a])return s[a];let o=r.length;return r.length+=3,lt.add(r,3*e,r,3*n,r,o),lt.scale(r,o,t/lt.length(r,o)),o/=3,s[a]=o,o}for(let t=0;t<e;t++){const t=o.length,e=new Uint32Array(4*t);for(let n=0;n<t;n+=3){const t=o[n],a=o[n+1],r=o[n+2],s=i(t,a),l=i(a,r),c=i(r,t),u=4*n;e[u]=t,e[u+1]=s,e[u+2]=c,e[u+3]=a,e[u+4]=l,e[u+5]=s,e[u+6]=r,e[u+7]=c,e[u+8]=l,e[u+9]=s,e[u+10]=l,e[u+11]=c}o=e,s={}}const l=new Float32Array(r);for(let t=0;t<l.length;t+=3)lt.normalize(l,t);const c=[["position",o],["normal",o]],u=[["position",{size:3,data:new Float32Array(r),exclusive:!0}],["normal",{size:3,data:l,exclusive:!0}]];return new y(u,c)},v.createPointGeometry=function(t,e,n,a,r,o,s){const i=e?[e[0],e[1],e[2]]:[0,0,0],l=t?[t[0],t[1],t[2]]:[0,0,1];o=o||[0,0];const c=n?[255*n[0],255*n[1],255*n[2],n.length>3?255*n[3]:255]:[255,255,255,255],u=null!=a&&2===a.length?a:[1,1],h=[["position",{size:3,data:i,exclusive:!0}],["normal",{size:3,data:l,exclusive:!0}],["uv0",{size:o.length,data:o}],["color",{size:4,data:c,exclusive:!0}],["size",{size:2,data:u}]];if(null!=r){const t=new Float32Array([r[0],r[1],r[2],r[3]]);h.push(["auxpos1",{size:4,data:t}])}if(null!=s){const t=new Float32Array([s[0],s[1],s[2],s[3]]);h.push(["auxpos2",{size:4,data:t}])}return new y(h,null,1)},v.updatePointGeometry=function(t,e,n,a,r,o,s,i){if(null!=t){const{data:e}=i.getMutableAttribute("normal");e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=e){const{data:t}=i.getMutableAttribute("position");t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=n){const{data:t}=i.getMutableAttribute("color");t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3]}if(null!=a){const{data:t}=i.getMutableAttribute("size");t[0]=a[0],t[1]=a[1]}if(null!=r){const{data:t}=i.getMutableAttribute("auxpos1");t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3]}if(null!=o){const{data:t}=i.getMutableAttribute("uv0");t[0]=o[0],t[1]=o[1]}if(null!=s){const{data:t}=i.getMutableAttribute("auxpos2");t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3]}},v.createPointArrayGeometry=function(t,e){const n=new Float32Array(3*t.length),a=new Float32Array(e?3*t.length:3),r=new Uint32Array(t.length),o=new Uint32Array(t.length);for(let s=0;s<t.length;s++)n[3*s]=t[s][0],n[3*s+1]=t[s][1],n[3*s+2]=t[s][2],e&&(a[3*s]=e[s][0],a[3*s+1]=e[s][1],a[3*s+2]=e[s][2]),r[s]=s,o[s]=0;return e||(a[0]=0,a[1]=1,a[2]=0),new y([["position",{size:3,data:n,exclusive:!0}],["normal",{size:3,data:a,exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]],[["position",r],["normal",e?r:o],["uv0",o]],1)},v.createTriangleGeometry=function(){const t=new Uint16Array([0,1,2]),e=new Uint16Array([0,0,0]),n=new Uint16Array([0,0,0]);return new y([["position",{size:3,data:[0,0,0,0,0,100,100,0,0],exclusive:!0}],["normal",{size:3,data:[0,1,0],exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]],[["position",t],["normal",e],["uv0",n]])};const w=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function b(t,a,r,s,i){return!(Math.abs(o(a,t))>i)&&(e(r,t,a),n(r,r),e(s,r,t),n(s,s),!0)}function A(t,e,n,a,r,o,s){return b(t,e,r,o,s)||b(t,n,r,o,s)||b(t,a,r,o,s)}v.createSquareGeometry=function(t=w){const e=new Array(12);for(let n=0;n<4;n++)for(let a=0;a<3;a++)e[3*n+a]=t[n][a];const n=new Uint32Array([0,1,2,2,3,0]),a=new Uint32Array([0,0,0,0,0,0]);return new y([["position",{size:3,data:e,exclusive:!0}],["normal",{size:3,data:[0,0,1],exclusive:!0}],["uv0",{size:2,data:[0,0,1,0,1,1,0,1],exclusive:!0}],["color",{size:4,data:[255,255,255,255],exclusive:!0}]],[["position",n],["normal",a],["uv0",n],["color",a]])},v.createConeGeometry=function(t,e,n,a,r=!0,o=!0){let s=0;const i=e,l=t;let c=u(0,s,0),h=u(0,s+l,0),p=u(0,-1,0),f=u(0,1,0);a&&(s=l,h=u(0,0,0),c=u(0,s,0),p=u(0,1,0),f=u(0,-1,0));const d=[h,c],m=[p,f],g=n+2,v=Math.sqrt(l*l+i*i);if(a)for(let t=n-1;t>=0;t--){const e=t*(2*Math.PI/n),a=u(Math.cos(e)*i,s,Math.sin(e)*i);d.push(a);const r=u(l*Math.cos(e)/v,-i/v,l*Math.sin(e)/v);m.push(r)}else for(let t=0;t<n;t++){const e=t*(2*Math.PI/n),a=u(Math.cos(e)*i,s,Math.sin(e)*i);d.push(a);const r=u(l*Math.cos(e)/v,i/v,l*Math.sin(e)/v);m.push(r)}const w=new Uint32Array(2*(n+2)*3),b=new Uint32Array(2*(n+2)*3);let A=0,x=0;if(r){for(let t=3;t<d.length;t++)w[A++]=1,w[A++]=t-1,w[A++]=t,b[x++]=0,b[x++]=0,b[x++]=0;w[A++]=d.length-1,w[A++]=2,w[A++]=1,b[x++]=0,b[x++]=0,b[x++]=0}if(o){for(let t=3;t<d.length;t++)w[A++]=t,w[A++]=t-1,w[A++]=0,b[x++]=t,b[x++]=t-1,b[x++]=1;w[A++]=0,w[A++]=2,w[A++]=d.length-1,b[x++]=1,b[x++]=2,b[x++]=m.length-1}const P=new Float32Array(3*g);for(let t=0;t<g;t++)P[3*t]=d[t][0],P[3*t+1]=d[t][1],P[3*t+2]=d[t][2];const z=new Float32Array(3*g);for(let t=0;t<g;t++)z[3*t]=m[t][0],z[3*t+1]=m[t][1],z[3*t+2]=m[t][2];return new y([["position",{size:3,data:P,exclusive:!0}],["normal",{size:3,data:z,exclusive:!0}]],[["position",w],["normal",b]])},v.createCylinderGeometry=function(t,i,l,c,f,d){const m=c?p(c):u(1,0,0),g=f?p(f):u(0,0,0);d=null==d||d;const v=h();n(v,m);const w=h();a(w,v,Math.abs(t));const b=h();a(b,w,-.5),r(b,b,g);const A=u(0,1,0);Math.abs(1-o(v,A))<.2&&s(A,0,0,1);const x=h();e(x,v,A),n(x,x),e(A,x,v);const P=2*l+(d?2:0),z=l+(d?2:0),M=new Float32Array(3*P),C=new Float32Array(3*z),F=new Float32Array(2*P),G=new Uint32Array(3*l*(d?4:2)),T=new Uint32Array(3*l*(d?4:2));d&&(M[3*(P-2)+0]=b[0],M[3*(P-2)+1]=b[1],M[3*(P-2)+2]=b[2],F[2*(P-2)]=0,F[2*(P-2)+1]=0,M[3*(P-1)+0]=M[3*(P-2)+0]+w[0],M[3*(P-1)+1]=M[3*(P-2)+1]+w[1],M[3*(P-1)+2]=M[3*(P-2)+2]+w[2],F[2*(P-1)]=1,F[2*(P-1)+1]=1,C[3*(z-2)+0]=-v[0],C[3*(z-2)+1]=-v[1],C[3*(z-2)+2]=-v[2],C[3*(z-1)+0]=v[0],C[3*(z-1)+1]=v[1],C[3*(z-1)+2]=v[2]);const U=function(t,e,n){G[t]=e,T[t]=n};let O=0;const q=h(),_=h();for(let t=0;t<l;t++){const e=t*(2*Math.PI/l);a(q,A,Math.sin(e)),a(_,x,Math.cos(e)),r(q,q,_),C[3*t+0]=q[0],C[3*t+1]=q[1],C[3*t+2]=q[2],a(q,q,i),r(q,q,b),M[3*t+0]=q[0],M[3*t+1]=q[1],M[3*t+2]=q[2],F[2*t+0]=t/l,F[2*t+1]=0,M[3*(t+l)+0]=M[3*t+0]+w[0],M[3*(t+l)+1]=M[3*t+1]+w[1],M[3*(t+l)+2]=M[3*t+2]+w[2],F[2*(t+l)+0]=t/l,F[2*t+1]=1;const n=(t+1)%l;U(O++,t,t),U(O++,t+l,t),U(O++,n,n),U(O++,n,n),U(O++,t+l,t),U(O++,n+l,n)}if(d){for(let t=0;t<l;t++){const e=(t+1)%l;U(O++,P-2,z-2),U(O++,t,z-2),U(O++,e,z-2)}for(let t=0;t<l;t++){const e=(t+1)%l;U(O++,t+l,z-1),U(O++,P-1,z-1),U(O++,e+l,z-1)}}return new y([["position",{size:3,data:M,exclusive:!0}],["normal",{size:3,data:C,exclusive:!0}],["uv0",{size:2,data:F,exclusive:!0}]],[["position",G],["normal",T],["uv0",G]])},v.createTubeGeometry=function(t,e,n,a,r){n=n||10,a=null==a||a,Y(t.length>1);const o=[],s=[];for(let t=0;t<n;t++){o.push([0,-t-1,-(t+1)%n-1]);const a=t/n*2*Math.PI;s.push([Math.cos(a)*e,Math.sin(a)*e])}return v.createPathExtrusionGeometry(s,t,[[0,0,0]],o,a,r)},v.createPathExtrusionGeometry=function(o,l,p,v,w,b=u(0,0,0)){const x=o.length,P=new Float32Array(l.length*x*3+(6*p.length||0)),z=new Float32Array(l.length*x*3+(p?6:0)),M=(l.length-1)*x*6+3*v.length*2,C=new Uint32Array(M),F=new Uint32Array(M);let G=0,T=0,U=0,O=0;const q=h(),_=h(),E=h(),D=h(),S=h(),j=h(),I=h(),H=c(),$=h(),B=h(),L=h(),V=h(),W=h(),k=f();s($,0,1,0),t(_,l[1],l[0]),n(_,_),w?(r(H,l[0],b),n(E,H)):s(E,0,0,1),A(_,E,$,$,S,E,ft),i(D,E),i(V,S);for(let t=0;t<p.length;t++)a(j,S,p[t][0]),a(H,E,p[t][2]),r(j,j,H),r(j,j,l[0]),P[G++]=j[0],P[G++]=j[1],P[G++]=j[2];z[T++]=-_[0],z[T++]=-_[1],z[T++]=-_[2];for(let t=0;t<v.length;t++)C[U++]=v[t][0]>0?v[t][0]:-v[t][0]-1+p.length,C[U++]=v[t][1]>0?v[t][1]:-v[t][1]-1+p.length,C[U++]=v[t][2]>0?v[t][2]:-v[t][2]-1+p.length,F[O++]=0,F[O++]=0,F[O++]=0;let N=p.length;const R=p.length-1;for(let s=0;s<l.length;s++){let c=!1;if(s>0){i(q,_),s<l.length-1?(t(_,l[s+1],l[s]),n(_,_)):c=!0,r(B,q,_),n(B,B),r(L,l[s-1],D),d(l[s],B,k);m(k,g(L,q),H)?(t(H,H,l[s]),n(E,H),e(S,B,E),n(S,S)):A(B,D,V,$,S,E,ft),i(D,E),i(V,S)}w&&(r(H,l[s],b),n(W,H));for(let t=0;t<x;t++)if(a(j,S,o[t][0]),a(H,E,o[t][1]),r(j,j,H),n(I,j),z[T++]=I[0],z[T++]=I[1],z[T++]=I[2],r(j,j,l[s]),P[G++]=j[0],P[G++]=j[1],P[G++]=j[2],!c){const e=(t+1)%x;C[U++]=N+t,C[U++]=N+x+t,C[U++]=N+e,C[U++]=N+e,C[U++]=N+x+t,C[U++]=N+x+e;for(let t=0;t<6;t++)F[O++]=C[U-6+t]-R}N+=x}const J=l[l.length-1];for(let t=0;t<p.length;t++)a(j,S,p[t][0]),a(H,E,p[t][1]),r(j,j,H),r(j,j,J),P[G++]=j[0],P[G++]=j[1],P[G++]=j[2];const K=T/3;z[T++]=_[0],z[T++]=_[1],z[T++]=_[2];const Q=N-x;for(let t=0;t<v.length;t++)C[U++]=v[t][0]>=0?N+v[t][0]:-v[t][0]-1+Q,C[U++]=v[t][2]>=0?N+v[t][2]:-v[t][2]-1+Q,C[U++]=v[t][1]>=0?N+v[t][1]:-v[t][1]-1+Q,F[O++]=K,F[O++]=K,F[O++]=K;return new y([["position",{size:3,data:P,exclusive:!0}],["normal",{size:3,data:z,exclusive:!0}]],[["position",C],["normal",F]])},v.createPolylineGeometry=function(t,e,n){Y(t.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),Y(3===t[0].length,"createPolylineGeometry(): malformed vertex"),Y(null==e||e.length===t.length,"createPolylineGeometry: need same number of points and normals"),Y(null==e||3===e[0].length,"createPolylineGeometry(): malformed normal");const a=new Float64Array(3*t.length),r=new Uint32Array(2*(t.length-1));let o=0,s=0;for(let e=0;e<t.length;e++){for(let n=0;n<3;n++)a[o++]=t[e][n];e>0&&(r[s++]=e-1,r[s++]=e)}const i=[],l=[];if(i.push(["position",r]),l.push(["position",{size:3,data:a,exclusive:!0}]),e){const n=new Float32Array(3*e.length);let a=0;for(let r=0;r<t.length;r++)for(let t=0;t<3;t++)n[a++]=e[r][t];i.push(["normal",r]),l.push(["normal",{size:3,data:n,exclusive:!0}])}return n&&(l.push(["color",{size:4,data:n}]),i.push(["color",X(n.length/4)])),new y(l,i,2)},v.createExtrudedTriangle=function(t,e,n,a,r=0){const o=new Array(18),s=[[-e,r,a/2],[n,r,a/2],[0,t+r,a/2],[-e,r,-a/2],[n,r,-a/2],[0,t+r,-a/2]],i=new Uint16Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]);for(let t=0;t<6;t++)o[3*t]=s[t][0],o[3*t+1]=s[t][1],o[3*t+2]=s[t][2];return new y([["position",{size:3,data:o,exclusive:!0}]],[["position",i]])},v.transformInPlace=function(t,e){const n=t.getMutableAttribute("position").data;for(let t=0;t<n.length;t+=3){const a=n[t],r=n[t+1],o=n[t+2];s(dt,a,r,o),l(dt,dt,e),n[t]=dt[0],n[t+1]=dt[1],n[t+2]=dt[2]}},v.cgToGIS=function(t,e=t){const n=t.vertexAttributes,a=n.get("position").data,r=n.get("normal").data;if(r){const t=e.getMutableAttribute("normal").data;for(let e=0;e<r.length;e+=3){const n=r[e+1];t[e+1]=-r[e+2],t[e+2]=n}}if(a){const t=e.getMutableAttribute("position").data;for(let e=0;e<a.length;e+=3){const n=a[e+1];t[e+1]=-a[e+2],t[e+2]=n}}return e},v.makeOrthoBasisDirUp=b,v.makeOrthoBasisDirUpFallback=A}(pt||(pt={}));const ft=.99619469809,dt=h();var mt=pt;const gt=Z().vec3f("position"),yt=Z().vec3f("position").vec2f("uv0"),vt=Z().vec3f("position").vec4u8("color");class wt{constructor(t){this.vertexBufferLayout=t}allocate(t){return this.vertexBufferLayout.createBuffer(t)}elementCount(t){return t.indices.get("position").length}write(t,e,n,a){tt(e,this.vertexBufferLayout,t.transformation,t.invTranspTransformation,n,a)}}var bt=Object.freeze({__proto__:null,build:function(t){const e=new v,n=1===t.output;return e.include(w,{linearDepth:n}),e.include(et,t),e.vertex.uniforms.add("proj","mat4").add("view","mat4"),e.attributes.add("position","vec3"),e.varyings.add("vpos","vec3"),t.multipassTerrainEnabled&&e.varyings.add("depth","float"),n&&(e.include(b,t),e.vertex.uniforms.add("cameraNearFar","vec2"),e.varyings.add("linearDepth","float")),e.vertex.code.add(A`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      ${t.multipassTerrainEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = ${n?A`transformPositionWithDepth(proj, view, vpos, cameraNearFar, linearDepth);`:A`transformPosition(proj, view, vpos);`}
    }
  `),e.include(x,t),e.fragment.include(P),t.multipassTerrainEnabled&&(e.fragment.include(z),e.include(M,t)),e.fragment.uniforms.add("eColor","vec4"),4===t.output&&e.include(C),e.fragment.code.add(A`
  void main() {
    discardBySlice(vpos);
    ${t.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
    vec4 color = ${t.attributeColor?"vColor * eColor;":"eColor;"}

    if (color.a < ${A.float(F)}) {
      discard;
    }

    ${7===t.output?A`gl_FragColor = vec4(color.a);`:""}

    ${0===t.output?A`gl_FragColor = highlightSlice(color, vpos); ${t.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}`:""}
    ${4===t.output?A`outputHighlight();`:""};
    ${1===t.output?A`outputDepth(linearDepth);`:""};
  }
  `),e}});class At extends O{initializeProgram(t){const e=At.shader.get(),n=this.configuration,a=e.build({output:n.output,OITEnabled:0===n.transparencyPassType,attributeColor:n.vertexColors,slicePlaneEnabled:n.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,multipassTerrainEnabled:n.multipassTerrainEnabled,cullAboveGround:n.cullAboveGround});return new q(t.rctx,a,_)}bindPass(t,e){E(this.program,e.camera.projectionMatrix),this.program.setUniform4fv("eColor",t.color),4===this.configuration.output&&D(this.program,e),(1===this.configuration.output||e.multipassTerrainEnabled)&&this.program.setUniform2fv("cameraNearFar",e.camera.nearFar),e.multipassTerrainEnabled&&(this.program.setUniform2fv("inverseViewport",e.inverseViewport),S(this.program,e))}bindDraw(t){j(this.program,t),this.program.rebindTextures(),I(this.program,this.configuration,t)}setPipelineState(t,e){const n=this.configuration,a=3===t,r=2===t;return at({blending:0!==n.output&&7!==n.output||!n.transparent?null:a?H:$(t),culling:rt(n.cullFace),depthTest:{func:B(t)},depthWrite:a||r?n.writeDepth&&ot:null,colorWrite:st,stencilWrite:n.sceneHasOcludees?L:null,stencilTest:n.sceneHasOcludees?e?V:W:null,polygonOffset:a||r?n.polygonOffset&&xt:k(n.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this.setPipelineState(this.configuration.transparencyPassType,!0),this.setPipelineState(this.configuration.transparencyPassType,!1)}getPipelineState(t){return t?this._occludeePipelineState:this.pipeline}}At.shader=new T(bt,(()=>Promise.resolve().then((function(){return bt}))));const xt={factor:1,units:1};class Pt extends U{constructor(){super(...arguments),this.output=0,this.cullFace=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.sceneHasOcludees=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}nt([G({count:8})],Pt.prototype,"output",void 0),nt([G({count:3})],Pt.prototype,"cullFace",void 0),nt([G()],Pt.prototype,"slicePlaneEnabled",void 0),nt([G()],Pt.prototype,"vertexColors",void 0),nt([G()],Pt.prototype,"transparent",void 0),nt([G()],Pt.prototype,"polygonOffset",void 0),nt([G()],Pt.prototype,"enableOffset",void 0),nt([G()],Pt.prototype,"writeDepth",void 0),nt([G()],Pt.prototype,"sceneHasOcludees",void 0),nt([G({count:4})],Pt.prototype,"transparencyPassType",void 0),nt([G()],Pt.prototype,"multipassTerrainEnabled",void 0),nt([G()],Pt.prototype,"cullAboveGround",void 0);class zt extends N{constructor(t){super(t,Ct),this.supportsEdges=!0,this.techniqueConfig=new Pt}getTechniqueConfig(t,e){return this.techniqueConfig.output=t,this.techniqueConfig.cullFace=this.params.cullFace,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig.transparencyPassType=e?e.transparencyPassType:3,this.techniqueConfig.enableOffset=!e||e.camera.relativeElevation<R,this.techniqueConfig.multipassTerrainEnabled=!!e&&e.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!!e&&e.cullAboveGround,this.techniqueConfig}getPassParameters(){return this.params}intersect(t,e,n,a,r,o,s){J(t,e,a,r,o,void 0,s)}getGLMaterial(t){return 0===t.output||7===t.output||4===t.output||1===t.output&&this.params.writeLinearDepth?new Mt(t):void 0}createBufferWriter(){return new wt(vt)}}class Mt extends K{constructor(t){super(t),this.updateParameters()}updateParameters(t){this._technique=this._techniqueRep.releaseAndAcquire(At,this._material.getTechniqueConfig(this._output,t),this._technique)}beginSlot(t){if(23===t)return!0;if(4===this._output)return 3===t;return t===(this._technique.configuration.transparent?this._technique.configuration.writeDepth?5:8:3)}_updateOccludeeState(t){t.hasOccludees!==this._material.params.sceneHasOcludees&&this._material.setParameterValues({sceneHasOcludees:t.hasOccludees})}ensureParameters(t){0!==this._output&&7!==this._output||this._updateOccludeeState(t),this.updateParameters(t)}bind(t){this._technique.bindPass(this._material.getPassParameters(),t)}getPipelineState(t,e){return this._technique.getPipelineState(e)}}const Ct={color:[1,1,1,1],transparent:!1,writeDepth:!0,writeLinearDepth:!1,vertexColors:!1,polygonOffset:!1,slicePlaneEnabled:!1,cullFace:0,sceneHasOcludees:!1,...Q};export{zt as C,wt as D,mt as G,yt as P,vt as a,gt as b};

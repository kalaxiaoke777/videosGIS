/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{g as t}from"../core/Accessor.js";import{i as s,b as e}from"../core/lang.js";import{m as r,e as i,d as a,a as o}from"./mat4.js";import{c as n}from"./mat4f64.js";import{s as h}from"./Util.js";import{n as f}from"./mat3.js";import{c as l,d as c}from"./quatf64.js";import{c as m}from"./quat.js";import{b,E as u,g as p,s as g}from"./mathUtils.js";import{c as v}from"./vec3f32.js";import{a as q}from"./vec4f64.js";import{c as z}from"./sphere.js";class S{constructor(){this.id=t()}unload(){}}function T(t,s,e){for(let r=0;r<e;++r)s[2*r]=t[r],s[2*r+1]=t[r]-s[2*r]}function y(t,s,e,r){for(let i=0;i<r;++i)d[0]=t[i],T(d,x,1),s[i]=x[0],e[i]=x[1]}const d=new Float64Array(1),x=new Float32Array(2);function M(t,s){return e(t)&&(t=[]),t.push(s),t}function _(t,s){if(e(t))return t;const r=t.filter((t=>t!==s));return 0===r.length?null:r}function V(t){return!!s(t)&&!t.visible}function O(t,s){const e=new Map;return e.set(0,s.acquire(t,0)),e.set(1,s.acquire(t,7)),e.set(4,s.acquire(t,3)),e.set(3,s.acquire(t,2)),e.set(2,s.acquire(t,1)),e.set(5,s.acquire(t,4)),e.set(7,s.acquire(t,3)),e.set(6,s.acquire(t,3)),e}function j(t,s){s.release(t,0),s.release(t,7),s.release(t,3),s.release(t,2),s.release(t,1),s.release(t,4)}function L(t,e,n){const f=t.origin.vec3;h(F,-f[0],-f[1],-f[2]),s(t.transformation)?r(e,F,t.transformation):i(e,F),n&&(a(n,e),o(n,n))}function w(t,s,e,r,i){I[0]=t.get(s,0),I[1]=t.get(s,1),I[2]=t.get(s,2),T(I,A,3),e.set(i,0,A[0]),r.set(i,0,A[1]),e.set(i,1,A[2]),r.set(i,1,A[3]),e.set(i,2,A[4]),r.set(i,2,A[5])}const I=new Float64Array(3),A=new Float32Array(6),F=n();class R{constructor(){this._transform=n(),this._transformInverse=new U({value:this._transform},a,n),this._transformInverseTranspose=new U(this._transformInverse,o,n),this._transformTranspose=new U({value:this._transform},o,n),this._transformInverseRotation=new U({value:this._transform},f,l)}invalidateLazyTransforms(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()}get transform(){return this._transform}get inverse(){return this._transformInverse.value}get inverseTranspose(){return this._transformInverseTranspose.value}get inverseRotation(){return this._transformInverseRotation.value}get transpose(){return this._transformTranspose.value}setTransformMatrix(t){i(this._transform,t)}multiplyTransform(t){r(this._transform,this._transform,t)}set(t){i(this._transform,t),this.invalidateLazyTransforms()}setAndInvalidateLazyTransforms(t,s){this.setTransformMatrix(t),this.multiplyTransform(s),this.invalidateLazyTransforms()}}class U{constructor(t,s,e){this.original=t,this.update=s,this.dirty=!0,this.transform=e()}invalidate(){this.dirty=!0}get value(){return this.dirty&&(this.update(this.transform,this.original.value),this.dirty=!1),this.transform}}const k=new class{constructor(t=0){this.offset=t,this.sphere=z(),this.tmpVertex=b()}applyToVertex(t,s,e){const r=this.objectTransform.transform;let i=r[0]*t+r[4]*s+r[8]*e+r[12],a=r[1]*t+r[5]*s+r[9]*e+r[13],o=r[2]*t+r[6]*s+r[10]*e+r[14];const n=this.offset/Math.sqrt(i*i+a*a+o*o);i+=i*n,a+=a*n,o+=o*n;const h=this.objectTransform.inverse;return this.tmpVertex[0]=h[0]*i+h[4]*a+h[8]*o+h[12],this.tmpVertex[1]=h[1]*i+h[5]*a+h[9]*o+h[13],this.tmpVertex[2]=h[2]*i+h[6]*a+h[10]*o+h[14],this.tmpVertex}applyToMinMax(t,s){const e=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*e,t[1]+=t[1]*e,t[2]+=t[2]*e;const r=this.offset/Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);s[0]+=s[0]*r,s[1]+=s[1]*r,s[2]+=s[2]*r}applyToAabb(t){const s=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*s,t[1]+=t[1]*s,t[2]+=t[2]*s;const e=this.offset/Math.sqrt(t[3]*t[3]+t[4]*t[4]+t[5]*t[5]);return t[3]+=t[3]*e,t[4]+=t[4]*e,t[5]+=t[5]*e,t}applyToBoundingSphere(t){const s=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),e=this.offset/s;return this.sphere[0]=t[0]+t[0]*e,this.sphere[1]=t[1]+t[1]*e,this.sphere[2]=t[2]+t[2]*e,this.sphere[3]=t[3]+t[3]*this.offset/s,this.sphere}};function B(t){return s(t)?(k.offset=t,k):null}const C=new class{constructor(t=0){this.offset=t,this.componentLocalOriginLength=0,this.tmpVertex=b(),this.mbs=q(),this.obb={center:b(),halfSize:v(),quaternion:null}}set localOrigin(t){this.componentLocalOriginLength=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}applyToVertex(t,s,e){const r=t,i=s,a=e+this.componentLocalOriginLength,o=this.offset/Math.sqrt(r*r+i*i+a*a);return this.tmpVertex[0]=t+r*o,this.tmpVertex[1]=s+i*o,this.tmpVertex[2]=e+a*o,this.tmpVertex}applyToAabb(t){const s=t[0],e=t[1],r=t[2]+this.componentLocalOriginLength,i=t[3],a=t[4],o=t[5]+this.componentLocalOriginLength,n=this.offset/Math.sqrt(s*s+e*e+r*r);t[0]+=s*n,t[1]+=e*n,t[2]+=r*n;const h=this.offset/Math.sqrt(i*i+a*a+o*o);return t[3]+=i*h,t[4]+=a*h,t[5]+=o*h,t}applyToMbs(t){const s=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),e=this.offset/s;return this.mbs[0]=t[0]+t[0]*e,this.mbs[1]=t[1]+t[1]*e,this.mbs[2]=t[2]+t[2]*e,this.mbs[3]=t[3]+t[3]*this.offset/s,this.mbs}applyToObb(t){const s=t.center,e=this.offset/Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);this.obb.center[0]=s[0]+s[0]*e,this.obb.center[1]=s[1]+s[1]*e,this.obb.center[2]=s[2]+s[2]*e,u(this.obb.halfSize,t.halfSize,t.quaternion),p(this.obb.halfSize,this.obb.halfSize,t.center);const r=this.offset/Math.sqrt(this.obb.halfSize[0]*this.obb.halfSize[0]+this.obb.halfSize[1]*this.obb.halfSize[1]+this.obb.halfSize[2]*this.obb.halfSize[2]);return this.obb.halfSize[0]+=this.obb.halfSize[0]*r,this.obb.halfSize[1]+=this.obb.halfSize[1]*r,this.obb.halfSize[2]+=this.obb.halfSize[2]*r,g(this.obb.halfSize,this.obb.halfSize,t.center),m(J,t.quaternion),u(this.obb.halfSize,this.obb.halfSize,J),this.obb.halfSize[0]*=this.obb.halfSize[0]<0?-1:1,this.obb.halfSize[1]*=this.obb.halfSize[1]<0?-1:1,this.obb.halfSize[2]*=this.obb.halfSize[2]<0?-1:1,this.obb.quaternion=t.quaternion,this.obb}};function E(t){return s(t)?(C.offset=t,C):null}const D=new class{constructor(t=0){this.offset=t,this.tmpVertex=b()}applyToVertex(t,s,e){const r=t+this.localOrigin[0],i=s+this.localOrigin[1],a=e+this.localOrigin[2],o=this.offset/Math.sqrt(r*r+i*i+a*a);return this.tmpVertex[0]=t+r*o,this.tmpVertex[1]=s+i*o,this.tmpVertex[2]=e+a*o,this.tmpVertex}applyToAabb(t){const s=t[0]+this.localOrigin[0],e=t[1]+this.localOrigin[1],r=t[2]+this.localOrigin[2],i=t[3]+this.localOrigin[0],a=t[4]+this.localOrigin[1],o=t[5]+this.localOrigin[2],n=this.offset/Math.sqrt(s*s+e*e+r*r);t[0]+=s*n,t[1]+=e*n,t[2]+=r*n;const h=this.offset/Math.sqrt(i*i+a*a+o*o);return t[3]+=i*h,t[4]+=a*h,t[5]+=o*h,t}};function G(t){return s(t)?(D.offset=t,D):null}const H="terrain",J=c();export{S as C,R as I,H as T,M as a,G as b,O as c,j as d,L as e,w as f,B as g,T as h,V as i,y as j,E as k,_ as r};

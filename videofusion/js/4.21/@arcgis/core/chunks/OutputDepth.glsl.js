/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{L as e}from"./Logger.js";import{o as t,b as i,i as r}from"../core/lang.js";import{M as s,b as n,j as a,u as o,h as c,p as l,U as u,m as d,c as h,e as f,a as m,n as p,s as g,Z as v}from"./mathUtils.js";import{P as _}from"../core/scheduling.js";import{a as x,T as b}from"./Texture.js";import{P,V as y,B as F,s as T,a as S,c as A}from"./VertexArrayObject.js";import{t as M}from"./mat4.js";import{c as I}from"./mat4f32.js";import{a as O}from"./Util.js";import{C as w,i as D}from"./verticalOffsetUtils.js";import{g as L,a as C,b as z}from"./geometryDataUtils.js";import{c as B,m as U,n as E}from"./aaBoundingBox.js";import{f as $}from"./vec4f64.js";function H(e,...t){let i="";for(let r=0;r<t.length;r++)i+=e[r]+t[r];return i+=e[e.length-1],i}function R(e){e.code.add(H`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}
const vec4 RGBA_2_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgba2float(vec4 rgba) {
return dot(rgba, RGBA_2_FLOAT_FACTORS);
}`)}function G(e){e.include(R),e.code.add(H`float linearDepthFromFloat(float depth, vec2 nearFar) {
return -(depth * (nearFar[1] - nearFar[0]) + nearFar[0]);
}
float linearDepthFromTexture(sampler2D depthTex, vec2 uv, vec2 nearFar) {
return linearDepthFromFloat(rgba2float(texture2D(depthTex, uv)), nearFar);
}`)}!function(e){e.int=function(e){return Math.round(e).toString()},e.float=function(e){return e.toPrecision(8)}}(H||(H={}));const V=e.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class j{constructor(){this.includedModules=new Map}include(e,t){this.includedModules.has(e)?this.includedModules.get(e)!==t&&V.error("Trying to include shader module multiple times with different sets of options."):(this.includedModules.set(e,t),e(this.builder,t))}}class k extends j{constructor(){super(...arguments),this.vertex=new W,this.fragment=new W,this.attributes=new Y,this.varyings=new K,this.extensions=new X,this.constants=new Z}get fragmentUniforms(){return this.fragment.uniforms}get builder(){return this}generateSource(e){const t=this.extensions.generateSource(e),i=this.attributes.generateSource(e),r=this.varyings.generateSource(),s="vertex"===e?this.vertex:this.fragment,n=s.uniforms.generateSource(),a=s.code.generateSource(),o="vertex"===e?Q:J,c=this.constants.generateSource().concat(s.constants.generateSource());return`\n${t.join("\n")}\n\n${o}\n\n${c.join("\n")}\n\n${n.join("\n")}\n\n${i.join("\n")}\n\n${r.join("\n")}\n\n${a.join("\n")}`}}class N{constructor(){this._entries=new Map}add(e,t,i){const r=`${e}_${t}_${i}`;return this._entries.set(r,{name:e,type:t,arraySize:i}),this}generateSource(){return Array.from(this._entries.values()).map((e=>{return`uniform ${e.type} ${e.name}${t=e.arraySize,t?`[${t}]`:""};`;var t}))}get entries(){return Array.from(this._entries.values())}}class q{constructor(){this._entries=new Array}add(e){this._entries.push(e)}generateSource(){return this._entries}}class W extends j{constructor(){super(...arguments),this.uniforms=new N,this.code=new q,this.constants=new Z}get builder(){return this}}class Y{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(e){return"fragment"===e?[]:this._entries.map((e=>`attribute ${e[1]} ${e[0]};`))}}class K{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(){return this._entries.map((e=>`varying ${e[1]} ${e[0]};`))}}class X{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const t="vertex"===e?X.ALLOWLIST_VERTEX:X.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter((e=>t.includes(e))).map((e=>`#extension ${e} : enable`))}}X.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],X.ALLOWLIST_VERTEX=[];class Z{constructor(){this._entries=[]}add(e,t,i){let r="ERROR_CONSTRUCTOR_STRING";switch(t){case"float":r=Z.numberToFloatStr(i);break;case"int":r=Z.numberToIntStr(i);break;case"bool":r=i.toString();break;case"vec2":r=`vec2(${Z.numberToFloatStr(i[0])},                            ${Z.numberToFloatStr(i[1])})`;break;case"vec3":r=`vec3(${Z.numberToFloatStr(i[0])},                            ${Z.numberToFloatStr(i[1])},                            ${Z.numberToFloatStr(i[2])})`;break;case"vec4":r=`vec4(${Z.numberToFloatStr(i[0])},                            ${Z.numberToFloatStr(i[1])},                            ${Z.numberToFloatStr(i[2])},                            ${Z.numberToFloatStr(i[3])})`;break;case"ivec2":r=`ivec2(${Z.numberToIntStr(i[0])},                             ${Z.numberToIntStr(i[1])})`;break;case"ivec3":r=`ivec3(${Z.numberToIntStr(i[0])},                             ${Z.numberToIntStr(i[1])},                             ${Z.numberToIntStr(i[2])})`;break;case"ivec4":r=`ivec4(${Z.numberToIntStr(i[0])},                             ${Z.numberToIntStr(i[1])},                             ${Z.numberToIntStr(i[2])},                             ${Z.numberToIntStr(i[3])})`;break;case"mat2":case"mat3":case"mat4":r=`${t}(${Array.prototype.map.call(i,(e=>Z.numberToFloatStr(e))).join(", ")})`}return this._entries.push(`const ${t} ${e} = ${r};`),this}static numberToIntStr(e){return e.toFixed(0)}static numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}}const J="#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif",Q="precision highp float;\nprecision highp sampler2D;";class ee{constructor(e,t){this._module=e,this._loadModule=t}get(){return this._module}async reload(){return this._module=await this._loadModule(),this._module}}class te{constructor(e,t,i=(()=>this.dispose())){this.release=i,t&&(this._config=t.snapshot()),this._program=this.initializeProgram(e),this._pipeline=this.initializePipeline(e)}dispose(){this._program=t(this._program),this._pipeline=this._config=null}reload(e){t(this._program),this._program=this.initializeProgram(e)}get program(){return this._program}get pipeline(){return this._pipeline}get key(){return this._config.key}get configuration(){return this._config}bindPass(e,t){}bindMaterial(e,t){}bindDraw(e,t,i){}bindPipelineState(e){e.setPipelineState(this.pipeline)}ensureAttributeLocations(e){this.program.assertCompatibleVertexAttributeLocations(e)}get primitiveType(){return 4}}class ie{constructor(){this._key="",this._keyDirty=!1,this._parameterBits=this._parameterBits.map((()=>0))}get key(){return this._keyDirty&&(this._keyDirty=!1,this._key=String.fromCharCode.apply(String,this._parameterBits)),this._key}snapshot(){const e=this._parameterNames,t={key:this.key};for(const i of e)t[i]=this[i];return t}}function re(e={}){return(t,i)=>{var r,n;t._parameterNames=null!=(r=t._parameterNames)?r:[],t._parameterNames.push(i);const a=t._parameterNames.length-1,o=e.count||2,c=Math.ceil(s(o)),l=null!=(n=t._parameterBits)?n:[0];let u=0;for(;l[u]+c>16;)u++,u>=l.length&&l.push(0);t._parameterBits=l;const d=l[u],h=(1<<c)-1<<d;l[u]+=c,Object.defineProperty(t,i,{get(){return this[a]},set(e){if(this[a]!==e&&(this[a]=e,this._keyDirty=!0,this._parameterBits[u]=this._parameterBits[u]&~h|+e<<d&h,"number"!=typeof e&&"boolean"!=typeof e))throw"Configuration value for "+i+" must be boolean or number, got "+typeof e}})}}const se=new Map([["position",0],["normal",1],["uv0",2],["color",3],["size",4],["tangent",4],["auxpos1",5],["symbolColor",5],["auxpos2",6],["featureAttribute",6],["instanceFeatureAttribute",6],["instanceColor",7],["model",8],["modelNormal",12],["modelOriginHi",11],["modelOriginLo",15]]);class ne extends P{constructor(e,t,i){super(e,t.generateSource("vertex"),t.generateSource("fragment"),i),this._textures=new Map,this._freeTextureUnits=new _({deallocator:null}),this._fragmentUniforms=x()?t.fragmentUniforms.entries:null}stop(){this._textures.clear(),this._freeTextureUnits.clear()}bindTexture(e,t){if(i(e)||null==e.glName){const e=this._textures.get(t);return e&&(this._context.bindTexture(null,e.unit),this._freeTextureUnit(e),this._textures.delete(t)),null}let r=this._textures.get(t);return null==r?(r=this._allocTextureUnit(e),this._textures.set(t,r)):r.texture=e,this._context.useProgram(this),this.setUniform1i(t,r.unit),this._context.bindTexture(e,r.unit),r.unit}rebindTextures(){this._context.useProgram(this),this._textures.forEach(((e,t)=>{this._context.bindTexture(e.texture,e.unit),this.setUniform1i(t,e.unit)})),r(this._fragmentUniforms)&&this._fragmentUniforms.forEach((e=>{if(("sampler2D"===e.type||"samplerCube"===e.type)&&!this._textures.has(e.name))throw new Error(`Texture sampler ${e.name} has no bound texture`)}))}_allocTextureUnit(e){return{texture:e,unit:0===this._freeTextureUnits.length?this._textures.size:this._freeTextureUnits.pop()}}_freeTextureUnit(e){this._freeTextureUnits.push(e.unit)}}const ae=[{name:"position",count:2,type:5126,offset:0,stride:8,normalized:!1}],oe=[{name:"position",count:2,type:5126,offset:0,stride:16,normalized:!1},{name:"uv0",count:2,type:5126,offset:8,stride:16,normalized:!1}];function ce(e,t=ae,i=se,r=-1,s=1){let n=null;if(t===oe)n=new Float32Array([r,r,0,0,s,r,1,0,r,s,0,1,s,s,1,1]);else n=new Float32Array([r,r,s,r,r,s,s,s]);return new y(e,i,{geometry:t},{geometry:F.createVertex(e,35044,n)})}function le(e,t=ae,i=se){const r=new Float32Array([-1,-1,3,-1,-1,3]);return new y(e,i,{geometry:t},{geometry:F.createVertex(e,35044,r)})}function ue(e,t=4){return new b(e,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,width:t,height:t})}function de(e,t,i=4){const r=new Uint8Array(i*i*4);for(let e=0;e<r.length;e+=4)r[e+0]=255*t[0],r[e+1]=255*t[1],r[e+2]=255*t[2],r[e+3]=255*t[3];return new b(e,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,width:i,height:i},r)}function he(e){return new b(e,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,width:1,height:1},new Uint8Array([255,255,255,255]))}function fe(e){e.code.add(H`vec4 premultiplyAlpha(vec4 v) {
return vec4(v.rgb * v.a, v.a);
}
vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);
}
vec3 hsv2rgb(vec3 c) {
vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
float rgb2v(vec3 c) {
return max(c.x, max(c.y, c.z));
}`)}function me(e,t){t.linearDepth?e.vertex.code.add(H`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;
return proj * eye;
}`):e.vertex.code.add(H`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function pe(e,t,i){e.setUniform3f("camPos",i[3]-t[0],i[7]-t[1],i[11]-t[2])}function ge(e,t){e.setUniformMatrix4fv("proj",t)}function ve(e,t){e.setUniform2fv("nearFar",t)}function _e(e,t,i){M(Pe,i,t),e.setUniform3fv("localOrigin",t),e.setUniformMatrix4fv("view",Pe)}function xe(e,t){_e(e,t.origin,t.camera.viewMatrix)}function be(e,t){e.setUniform4fv("viewport",t.camera.fullViewport)}const Pe=I();class ye{constructor(e,t,i,r){this.primitiveIndices=e,this._numIndexPerPrimitive=t,this.indices=i,this.position=r,this.center=n(),O(e.length>=1),O(i.length%this._numIndexPerPrimitive==0),O(i.length>=e.length*this._numIndexPerPrimitive),O(3===r.size||4===r.size);const{data:s,size:l}=r,u=e.length;let d=l*i[this._numIndexPerPrimitive*e[0]];Fe.clear(),Fe.push(d),this.bbMin=a(s[d],s[d+1],s[d+2]),this.bbMax=o(this.bbMin);for(let t=0;t<u;++t){const r=this._numIndexPerPrimitive*e[t];for(let e=0;e<this._numIndexPerPrimitive;++e){d=l*i[r+e],Fe.push(d);let t=s[d];this.bbMin[0]=Math.min(t,this.bbMin[0]),this.bbMax[0]=Math.max(t,this.bbMax[0]),t=s[d+1],this.bbMin[1]=Math.min(t,this.bbMin[1]),this.bbMax[1]=Math.max(t,this.bbMax[1]),t=s[d+2],this.bbMin[2]=Math.min(t,this.bbMin[2]),this.bbMax[2]=Math.max(t,this.bbMax[2])}}c(this.center,this.bbMin,this.bbMax,.5),this.radius=.5*Math.max(Math.max(this.bbMax[0]-this.bbMin[0],this.bbMax[1]-this.bbMin[1]),this.bbMax[2]-this.bbMin[2]);let h=this.radius*this.radius;for(let e=0;e<Fe.length;++e){d=Fe.getItemAt(e);const t=s[d]-this.center[0],i=s[d+1]-this.center[1],r=s[d+2]-this.center[2],n=t*t+i*i+r*r;if(n<=h)continue;const a=Math.sqrt(n),o=.5*(a-this.radius);this.radius=this.radius+o,h=this.radius*this.radius;const c=o/a;this.center[0]+=t*c,this.center[1]+=i*c,this.center[2]+=r*c}Fe.clear()}getCenter(){return this.center}getBSRadius(){return this.radius}getBBMin(){return this.bbMin}getBBMax(){return this.bbMax}getChildren(){if(this._children)return this._children;if(l(this.bbMin,this.bbMax)>1){const e=c(n(),this.bbMin,this.bbMax,.5),t=this.primitiveIndices.length,i=new Uint8Array(t),r=new Array(8);for(let e=0;e<8;++e)r[e]=0;const{data:s,size:a}=this.position;for(let n=0;n<t;++n){let t=0;const o=this._numIndexPerPrimitive*this.primitiveIndices[n];let c=a*this.indices[o],l=s[c],u=s[c+1],d=s[c+2];for(let e=1;e<this._numIndexPerPrimitive;++e){c=a*this.indices[o+e];const t=s[c],i=s[c+1],r=s[c+2];t<l&&(l=t),i<u&&(u=i),r<d&&(d=r)}l<e[0]&&(t|=1),u<e[1]&&(t|=2),d<e[2]&&(t|=4),i[n]=t,++r[t]}let o=0;for(let e=0;e<8;++e)r[e]>0&&++o;if(o<2)return;const l=new Array(8);for(let e=0;e<8;++e)l[e]=r[e]>0?new Uint32Array(r[e]):void 0;for(let e=0;e<8;++e)r[e]=0;for(let e=0;e<t;++e){const t=i[e];l[t][r[t]++]=this.primitiveIndices[e]}this._children=new Array(8);for(let e=0;e<8;++e)void 0!==l[e]&&(this._children[e]=new ye(l[e],this._numIndexPerPrimitive,this.indices,this.position))}return this._children}static prune(){Fe.prune()}}const Fe=new _({deallocator:null});class Te extends w{constructor(e,t=[],i=0,r=-1){super(),this._primitiveType=i,this.edgeIndicesLength=r,this.type=2,this._vertexAttributes=new Map,this._indices=new Map,this._boundingInfo=null;for(const[t,i]of e)i&&this._vertexAttributes.set(t,{...i});if(null==t||0===t.length){const e=function(e){const t=e.values().next().value;if(null==t)return 0;return t.data.length/t.size}(this._vertexAttributes),t=L(e);this.edgeIndicesLength=this.edgeIndicesLength<0?e:this.edgeIndicesLength;for(const e of this._vertexAttributes.keys())this._indices.set(e,t)}else for(const[e,i]of t)i&&(this._indices.set(e,Se(i)),"position"===e&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._indices.get(e).length:this.edgeIndicesLength))}get vertexAttributes(){return this._vertexAttributes}getMutableAttribute(e){const t=this._vertexAttributes.get(e);return t&&!t.exclusive&&(t.data=Array.from(t.data),t.exclusive=!0),t}get indices(){return this._indices}get indexCount(){const e=this._indices.values().next().value;return e?e.length:0}get primitiveType(){return this._primitiveType}get faceCount(){return this.indexCount/3}get boundingInfo(){return i(this._boundingInfo)&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(e){return 0===this.primitiveType?this.computeAttachmentOriginTriangles(e):this.computeAttachmentOriginPoints(e)}computeAttachmentOriginTriangles(e){const t=this.indices.get("position"),i=this.vertexAttributes.get("position");return C(i,t,e)}computeAttachmentOriginPoints(e){const t=this.indices.get("position"),i=this.vertexAttributes.get("position");return z(i,t,e)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const e=this.indices.get("position");if(0===e.length)return null;const t=0===this.primitiveType?3:1;O(e.length%t==0,"Indexing error: "+e.length+" not divisible by "+t);const i=L(e.length/t),r=this.vertexAttributes.get("position");return new ye(i,t,e,r)}}function Se(e){if(e.BYTES_PER_ELEMENT===Uint16Array.BYTES_PER_ELEMENT)return e;for(const t of e)if(t>=65536)return e;return new Uint16Array(e)}function Ae(e,t){return new Ce(e,ze,t)}function Me(e,t){const{curvatureDependent:i,scaleStart:r,scaleFallOffRange:s}=ze;return new Ce(e,{curvatureDependent:{min:{curvature:i.min.curvature,tiltAngle:i.min.tiltAngle,scaleFallOffFactor:Be.curvatureDependent.min.scaleFallOffFactor},max:{curvature:i.max.curvature,tiltAngle:i.max.tiltAngle,scaleFallOffFactor:Be.curvatureDependent.max.scaleFallOffFactor}},scaleStart:r,scaleFallOffRange:s,minPixelSize:Be.minPixelSize},t)}function Ie(e,t,i){const r=i.parameters,s=i.paddingPixelsOverride;return Ue.scale=Math.min(r.divisor/(t-r.offset),1),Ue.factor=function(e){return Math.abs(e*e*e)}(e),Ue.minPixelSize=r.minPixelSize,Ue.paddingPixels=s,Ue}function Oe(e,t){return 0===e?t.minPixelSize:t.minPixelSize*(1+2*t.paddingPixels/e)}function we(e,t){return Math.max(u(e*t.scale,e,t.factor),Oe(e,t))}function De(e,t,i,r){r.scale=function(e,t,i){const r=Ie(e,t,i);return r.minPixelSize=0,r.paddingPixels=0,we(1,r)}(e,t,i),r.factor=0,r.minPixelSize=i.parameters.minPixelSize,r.paddingPixels=i.paddingPixelsOverride}function Le(e,t,i=[0,0]){const r=Math.min(Math.max(t.scale,Oe(e[1],t)/e[1]),1);return i[0]=e[0]*r,i[1]=e[1]*r,i}class Ce{constructor(e,t,i,r={camera:{distance:0,fovY:0},divisor:0,offset:0,minPixelSize:0,paddingPixels:0},s){this.viewingMode=e,this.description=t,this.ellipsoidRadius=i,this.parameters=r,this._paddingPixelsOverride=s,2===this.viewingMode?(this.coverageCompensation=this.surfaceCoverageCompensationLocal,this.calculateCurvatureDependentParameters=this.calculateCurvatureDependentParametersLocal):(this.coverageCompensation=this.surfaceCoverageCompensationGlobal,this.calculateCurvatureDependentParameters=this.calculateCurvatureDependentParametersGlobal)}get paddingPixelsOverride(){return this._paddingPixelsOverride||this.parameters.paddingPixels}update(e){return(!this.parameters||this.parameters.camera.fovY!==e.fovY||this.parameters.camera.distance!==e.distance)&&(this.calculateParameters(e,this.ellipsoidRadius,this.parameters),!0)}overridePadding(e){return e!==this.paddingPixelsOverride?new Ce(this.viewingMode,this.description,this.ellipsoidRadius,this.parameters,e):this}calculateParameters(e,t,i){const{scaleStart:r,scaleFallOffRange:s,minPixelSize:n}=this.description,{fovY:a,distance:o}=e,c=this.calculateCurvatureDependentParameters(e,t),l=this.coverageCompensation(e,t,c),{tiltAngle:u,scaleFallOffFactor:d}=c,h=Math.sin(u)*o,f=.5*Math.PI-u-a*(.5-r*l),m=h/Math.cos(f),p=f+a*s*l,g=(m-d*(h/Math.cos(p)))/(1-d);return i.camera.fovY=e.fovY,i.camera.distance=e.distance,i.offset=g,i.divisor=m-g,i.minPixelSize=n,i}calculateCurvatureDependentParametersLocal(e,t,i=Ee){return i.tiltAngle=this.description.curvatureDependent.min.tiltAngle,i.scaleFallOffFactor=this.description.curvatureDependent.min.scaleFallOffFactor,i}calculateCurvatureDependentParametersGlobal(e,t,i=Ee){const r=this.description.curvatureDependent,s=1+e.distance/t,n=Math.sqrt(s*s-1),[a,o]=[r.min.curvature,r.max.curvature],c=h((n-a)/(o-a),0,1),[l,d]=[r.min,r.max];return i.tiltAngle=u(l.tiltAngle,d.tiltAngle,c),i.scaleFallOffFactor=u(l.scaleFallOffFactor,d.scaleFallOffFactor,c),i}surfaceCoverageCompensationLocal(e,t,i){return(e.fovY-i.tiltAngle)/e.fovY}surfaceCoverageCompensationGlobal(e,t,i){const r=t*t,s=i.tiltAngle+.5*Math.PI,{fovY:n,distance:a}=e,o=a*a+r-2*Math.cos(s)*a*t,c=Math.sqrt(o),l=Math.sqrt(o-r);return(Math.acos(l/c)-Math.asin(t/(c/Math.sin(s)))+.5*n)/n}}const ze={curvatureDependent:{min:{curvature:d(10),tiltAngle:d(12),scaleFallOffFactor:.5},max:{curvature:d(70),tiltAngle:d(40),scaleFallOffFactor:.8}},scaleStart:.3,scaleFallOffRange:.65,minPixelSize:0},Be={curvatureDependent:{min:{scaleFallOffFactor:.7},max:{scaleFallOffFactor:.95}},minPixelSize:14};const Ue={scale:0,factor:0,minPixelSize:0,paddingPixels:0},Ee={tiltAngle:0,scaleFallOffFactor:0},$e=e=>class extends e{constructor(){super(...arguments),this._isDisposed=!1}dispose(){for(const t of null!=(e=this._managedDisposables)?e:[]){var e;const i=this[t];this[t]=null,i&&"function"==typeof i.dispose&&i.dispose()}this._isDisposed=!0}get isDisposed(){return this._isDisposed}};class He extends($e(class{})){}function Re(){return(e,t)=>{var i,r;e.hasOwnProperty("_managedDisposables")||(e._managedDisposables=null!=(i=null==(r=e._managedDisposables)?void 0:r.slice())?i:[]);e._managedDisposables.unshift(t)}}class Ge extends He{constructor(e){super(),this._material=e.material,this._techniqueRep=e.techniqueRep,this._output=e.output}get technique(){return this._technique}getPipelineState(e,t){return this.technique.pipeline}ensureResources(e){return 2}ensureParameters(e){}}const Ve=B();function je(e,t,i,r,s,n,a){if(!D(t))if(e.boundingInfo){O(0===e.primitiveType);const t=i.tolerance;Ne(e.boundingInfo,r,s,t,n,a)}else{const t=e.indices.get("position"),i=e.vertexAttributes.get("position");We(r,s,0,t.length/3,t,i,void 0,n,a)}}const ke=n();function Ne(e,t,s,n,a,o){if(i(e))return;const c=Ze(t,s,ke);if(U(Ve,e.getBBMin()),E(Ve,e.getBBMax()),r(a)&&a.applyToAabb(Ve),Je(Ve,t,c,n)){const{primitiveIndices:i,indices:r,position:c}=e,l=i?i.length:r.length/3;if(l>ot){const i=e.getChildren();if(void 0!==i){for(let e=0;e<8;++e)void 0!==i[e]&&Ne(i[e],t,s,n,a,o);return}}We(t,s,0,l,r,c,i,a,o)}}const qe=n();function We(e,t,i,s,n,a,o,c,l){if(o)return function(e,t,i,s,n,a,o,c,l){const u=a.data,d=a.stride||a.size,h=e[0],f=e[1],m=e[2],p=t[0],g=t[1],v=t[2],_=p-h,x=g-f,b=v-m;for(let e=i;e<s;++e){const t=o[e];let i=3*t,s=d*n[i++],a=u[s++],p=u[s++],g=u[s];s=d*n[i++];let v=u[s++],P=u[s++],y=u[s];s=d*n[i];let F=u[s++],T=u[s++],S=u[s];r(c)&&([a,p,g]=c.applyToVertex(a,p,g,e),[v,P,y]=c.applyToVertex(v,P,y,e),[F,T,S]=c.applyToVertex(F,T,S,e));const A=v-a,M=P-p,I=y-g,O=F-a,w=T-p,D=S-g,L=x*D-w*b,C=b*O-D*_,z=_*w-O*x,B=A*L+M*C+I*z;if(Math.abs(B)<=Number.EPSILON)continue;const U=h-a,E=f-p,$=m-g,H=U*L+E*C+$*z;if(B>0){if(H<0||H>B)continue}else if(H>0||H<B)continue;const R=E*I-M*$,G=$*A-I*U,V=U*M-A*E,j=_*R+x*G+b*V;if(B>0){if(j<0||H+j>B)continue}else if(j>0||H+j<B)continue;const k=(O*R+w*G+D*V)/B;if(k>=0){l(k,Xe(A,M,I,O,w,D,qe),t)}}}(e,t,i,s,n,a,o,c,l);const u=a.data,d=a.stride||a.size,h=e[0],f=e[1],m=e[2],p=t[0]-h,g=t[1]-f,v=t[2]-m;for(let e=i,t=3*i;e<s;++e){let i=d*n[t++],s=u[i++],a=u[i++],o=u[i];i=d*n[t++];let _=u[i++],x=u[i++],b=u[i];i=d*n[t++];let P=u[i++],y=u[i++],F=u[i];r(c)&&([s,a,o]=c.applyToVertex(s,a,o,e),[_,x,b]=c.applyToVertex(_,x,b,e),[P,y,F]=c.applyToVertex(P,y,F,e));const T=_-s,S=x-a,A=b-o,M=P-s,I=y-a,O=F-o,w=g*O-I*v,D=v*M-O*p,L=p*I-M*g,C=T*w+S*D+A*L;if(Math.abs(C)<=Number.EPSILON)continue;const z=h-s,B=f-a,U=m-o,E=z*w+B*D+U*L;if(C>0){if(E<0||E>C)continue}else if(E>0||E<C)continue;const $=B*A-S*U,H=U*T-A*z,R=z*S-T*B,G=p*$+g*H+v*R;if(C>0){if(G<0||E+G>C)continue}else if(G>0||E+G<C)continue;const V=(M*$+I*H+O*R)/C;if(V>=0){l(V,Xe(T,S,A,M,I,O,qe),e)}}}const Ye=n(),Ke=n();function Xe(e,t,i,r,s,n,a){return f(Ye,e,t,i),f(Ke,r,s,n),m(a,Ye,Ke),p(a,a),a}function Ze(e,t,i){return f(i,1/(t[0]-e[0]),1/(t[1]-e[1]),1/(t[2]-e[2]))}function Je(e,t,i,r){return Qe(e,t,i,r,1/0)}function Qe(e,t,i,r,s){const n=(e[0]-r-t[0])*i[0],a=(e[3]+r-t[0])*i[0];let o=Math.min(n,a),c=Math.max(n,a);const l=(e[1]-r-t[1])*i[1],u=(e[4]+r-t[1])*i[1];if(c=Math.min(c,Math.max(l,u)),c<0)return!1;if(o=Math.max(o,Math.min(l,u)),o>c)return!1;const d=(e[2]-r-t[2])*i[2],h=(e[5]+r-t[2])*i[2];return c=Math.min(c,Math.max(d,h)),!(c<0)&&(o=Math.max(o,Math.min(d,h)),!(o>c)&&o<s)}function et(e,t,i,r,s){let n=(i.screenLength||0)*e.pixelRatio;s&&(n=function(e,t,i,r){return we(e,Ie(t,i,r))}(n,r,t,s));const a=n*Math.tan(.5*e.fovY)/(.5*e.fullHeight);return h(a*t,i.minWorldLength||0,null!=i.maxWorldLength?i.maxWorldLength:1/0)}function tt(e,t,i){if(!e)return;const r=e.parameters,s=e.paddingPixelsOverride;t.setUniform4f(i,r.divisor,r.offset,r.minPixelSize,s)}function it(e,t){const i=t?it(t):{};for(const t in e){let r=e[t];r&&r.forEach&&(r=nt(r)),null==r&&t in i||(i[t]=r)}return i}function rt(e,t){let i=!1;for(const r in t){const s=t[r];void 0!==s&&(i=!0,Array.isArray(s)?e[r]=s.slice():e[r]=s)}return i}function st(e,t,i,r,s){if(!t.options.selectionMode)return;const n=e.vertexAttributes.get("position").data,a=e.vertexAttributes.get("size"),o=a&&a.data[0],c=i[0],l=i[1],u=((o+r)/2+4)*e.screenToWorldRatio;let d=Number.MAX_VALUE;for(let e=0;e<n.length-5;e+=3){const t=n[e],i=n[e+1],r=c-t,s=l-i,a=n[e+3]-t,o=n[e+4]-i,u=h((a*r+o*s)/(a*a+o*o),0,1),f=a*u-r,m=o*u-s,p=f*f+m*m;p<d&&(d=p)}d<u*u&&s()}function nt(e){const t=[];return e.forEach((e=>t.push(e))),t}const at={multiply:1,ignore:2,replace:3,tint:4},ot=1e3;class ct extends w{constructor(e,t){super(),this.type=3,this.supportsEdges=!1,this._visible=!0,this._renderPriority=0,this._insertOrder=0,this._vertexAttributeLocations=se,this._params=it(e,t),this.validateParameterValues(this._params)}dispose(){}get params(){return this._params}update(e){return!1}setParameterValues(e){rt(this._params,e)&&(this.validateParameterValues(this._params),this.parametersChanged())}validateParameterValues(e){}get visible(){return this._visible}set visible(e){e!==this._visible&&(this._visible=e,this.parametersChanged())}isVisibleInPass(e){return!0}get renderOccluded(){return this.params.renderOccluded}get renderPriority(){return this._renderPriority}set renderPriority(e){e!==this._renderPriority&&(this._renderPriority=e,this.parametersChanged())}get insertOrder(){return this._insertOrder}set insertOrder(e){e!==this._insertOrder&&(this._insertOrder=e,this.parametersChanged())}get vertexAttributeLocations(){return this._vertexAttributeLocations}isVisible(){return this._visible}parametersChanged(){r(this.materialRepository)&&this.materialRepository.materialChanged(this)}}function lt(e,t){return e.isVisible()&&e.isVisibleInPass(t.pass)&&0!=(e.renderOccluded&t.renderOccludedMask)}const ut={renderOccluded:1};function dt(e,t){if(t.slicePlaneEnabled){e.extensions.add("GL_OES_standard_derivatives"),t.sliceEnabledForVertexPrograms&&(e.vertex.uniforms.add("slicePlaneOrigin","vec3"),e.vertex.uniforms.add("slicePlaneBasis1","vec3"),e.vertex.uniforms.add("slicePlaneBasis2","vec3")),e.fragment.uniforms.add("slicePlaneOrigin","vec3"),e.fragment.uniforms.add("slicePlaneBasis1","vec3"),e.fragment.uniforms.add("slicePlaneBasis2","vec3");const i=H`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
};
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);
return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2
);
}
bool sliceByFactors(SliceFactors factors) {
return factors.front < 0.0
&& factors.side0 < 0.0
&& factors.side1 < 0.0
&& factors.side2 < 0.0
&& factors.side3 < 0.0;
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
#define rejectBySlice(_pos_) sliceByPlane(_pos_)
#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }`,r=H`vec4 applySliceHighlight(vec4 color, vec3 pos) {
SliceFactors factors = calculateSliceFactors(pos);
if (sliceByFactors(factors)) {
return color;
}
const float HIGHLIGHT_WIDTH = 1.0;
const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);
factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);
factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);
factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);
factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);
factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);
float highlightFactor = (1.0 - step(0.5, factors.front))
* (1.0 - step(0.5, factors.side0))
* (1.0 - step(0.5, factors.side1))
* (1.0 - step(0.5, factors.side2))
* (1.0 - step(0.5, factors.side3));
return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);
}`,s=t.sliceHighlightDisabled?H`#define highlightSlice(_color_, _pos_) (_color_)`:H`
        ${r}
        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))
      `;t.sliceEnabledForVertexPrograms&&e.vertex.code.add(i),e.fragment.code.add(i),e.fragment.code.add(s)}else{const i=H`#define rejectBySlice(_pos_) false
#define discardBySlice(_pos_) {}
#define highlightSlice(_color_, _pos_) (_color_)`;t.sliceEnabledForVertexPrograms&&e.vertex.code.add(i),e.fragment.code.add(i)}}function ht(e,t,i){ft(e,t,i.slicePlane,i.origin)}function ft(e,t,i,s){t.slicePlaneEnabled&&(r(i)?(s?(g(mt,i.origin,s),e.setUniform3fv("slicePlaneOrigin",mt)):e.setUniform3fv("slicePlaneOrigin",i.origin),e.setUniform3fv("slicePlaneBasis1",i.basis1),e.setUniform3fv("slicePlaneBasis2",i.basis2)):(e.setUniform3fv("slicePlaneBasis1",v),e.setUniform3fv("slicePlaneBasis2",v),e.setUniform3fv("slicePlaneOrigin",v)))}const mt=n(),pt=$(1,1,0,1),gt=$(1,0,1,1);function vt(e){e.fragment.uniforms.add("depthTex","sampler2D"),e.fragment.uniforms.add("highlightViewportPixelSz","vec4"),e.fragment.constants.add("occludedHighlightFlag","vec4",pt).add("unoccludedHighlightFlag","vec4",gt),e.fragment.code.add(H`void outputHighlight() {
vec4 fragCoord = gl_FragCoord;
float sceneDepth = texture2D(depthTex, (fragCoord.xy - highlightViewportPixelSz.xy) * highlightViewportPixelSz.zw).r;
if (fragCoord.z > sceneDepth + 5e-7) {
gl_FragColor = occludedHighlightFlag;
}
else {
gl_FragColor = unoccludedHighlightFlag;
}
}`)}function _t(e,t){e.bindTexture(t.highlightDepthTexture,"depthTex"),e.setUniform4f("highlightViewportPixelSz",0,0,t.inverseViewport[0],t.inverseViewport[1])}const xt=.1,bt=.001;function Pt(e,t){const i=e.fragment;switch(t.alphaDiscardMode){case 0:i.code.add(H`
        #define discardOrAdjustAlpha(color) { if (color.a < ${H.float(.001)}) { discard; } }
      `);break;case 1:i.code.add(H`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`);break;case 2:i.uniforms.add("textureAlphaCutoff","float"),i.code.add(H`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`);break;case 3:e.fragment.uniforms.add("textureAlphaCutoff","float"),e.fragment.code.add(H`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`)}}function yt(e,t){e.fragment.uniforms.add("terrainDepthTexture","sampler2D"),e.fragment.uniforms.add("cameraNearFar","vec2"),e.fragment.uniforms.add("inverseViewport","vec2"),e.fragment.code.add(H`
    // Compare the linearized depths of fragment and terrain. Discard fragments on the wrong side of the terrain.
    void terrainDepthTest(vec4 fragCoord, float fragmentDepth){

      float terrainDepth = linearDepthFromTexture(terrainDepthTexture, fragCoord.xy * inverseViewport, cameraNearFar);
      if(fragmentDepth ${t.cullAboveGround?">":"<="} terrainDepth){
        discard;
      }
    }
  `)}function Ft(e,t){t.multipassTerrainEnabled&&t.terrainLinearDepthTexture&&e.bindTexture(t.terrainLinearDepthTexture,"terrainDepthTexture")}const Tt=T(770,1,771,771),St=S(1,1),At=S(0,771);function Mt(e){return 2===e?null:1===e?At:St}function It(e){return 2===e?A:null}const Ot=5e5,wt={factor:-1,units:-2};function Dt(e){return e?wt:null}function Lt(e){return 3===e||2===e?513:515}const Ct={func:513},zt={func:519},Bt={mask:255},Ut={mask:0},Et=e=>({function:{func:517,ref:e,mask:e},operation:{fail:7680,zFail:7680,zPass:7680}}),$t=e=>({function:{func:519,ref:e,mask:e},operation:{fail:7680,zFail:7680,zPass:7681}}),Ht={function:{func:519,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:0}},Rt={function:{func:519,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:7681}},Gt={function:{func:514,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:7680}},Vt={function:{func:517,ref:2,mask:2},operation:{fail:7680,zFail:7680,zPass:7680}};function jt(e,t){e.fragment.include(R),3===t.output?(e.extensions.add("GL_OES_standard_derivatives"),e.fragment.code.add(H`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 2.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
float result = depth + SLOPE_SCALE * m + BIAS;
return clamp(result, .0, .999999);
}
void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));
}`)):1===t.output&&e.fragment.code.add(H`void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_linearDepth);
}`)}export{xe as $,He as A,bt as B,fe as C,se as D,yt as E,_t as F,Tt as G,Mt as H,Lt as I,Bt as J,$t as K,Ht as L,wt as M,xt as N,jt as O,ne as P,ae as Q,G as R,k as S,me as T,gt as U,le as V,Ft as W,ye as X,lt as Y,he as Z,$e as _,ee as a,ht as a0,It as a1,Rt as a2,zt as a3,Vt as a4,Ut as a5,Gt as a6,Ct as a7,ut as a8,ct as a9,Ge as aa,Te as ab,pe as ac,Dt as ad,be as ae,at as af,ve as ag,Ot as ah,je as ai,At as aj,_e as ak,et as al,we as am,De as an,st as ao,it as ap,rt as aq,ie as b,te as c,ce as d,oe as e,R as f,H as g,ge as h,Le as i,Ae as j,Me as k,Xe as l,Qe as m,de as n,ue as o,re as p,dt as q,vt as r,Et as s,tt as t,ft as u,We as v,Re as w,Ze as x,Je as y,Pt as z};

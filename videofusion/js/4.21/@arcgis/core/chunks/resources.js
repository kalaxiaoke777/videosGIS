/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{b as t,e,l as i,f as s,c as a}from"./mathUtils.js";import{t as r}from"./vec2.js";import{f as l}from"./vec2f64.js";import{i as n}from"./viewpointUtils.js";import{throwIfAborted as o}from"../core/promiseUtils.js";import{r as h}from"./requestImageUtils.js";class c{constructor(t){this.gain=t}update(t){if(this.hasLastValue){const e=this.computeDelta(t);this.updateDelta(e)}this.lastValue=t}reset(){this.lastValue=void 0,this.filteredDelta=void 0}get hasLastValue(){return void 0!==this.lastValue}get hasFilteredDelta(){return void 0!==this.filteredDelta}computeDelta(t){return t-this.lastValue}updateDelta(t){this.hasFilteredDelta?this.filteredDelta=(1-this.gain)*this.filteredDelta+this.gain*t:this.filteredDelta=t}}class u{constructor(t,e,i){this._initialVelocity=t,this._stopVelocity=e,this._friction=i,this._duration=Math.abs(Math.log(Math.abs(this._initialVelocity)/this._stopVelocity)/Math.log(1-this._friction))}get duration(){return this._duration}isFinished(t){return t>this.duration}get friction(){return this._friction}value(t){return this.valueFromInitialVelocity(this._initialVelocity,t)}valueDelta(t,e){const i=this.value(t);return this.value(t+e)-i}valueFromInitialVelocity(t,e){e=Math.min(e,this.duration);const i=1-this.friction;return t*(i**e-1)/Math.log(i)}}class m extends u{constructor(t,e,i,s,a){super(t,e,i),this.sceneVelocity=s,this.direction=a}value(t){return super.valueFromInitialVelocity(this.sceneVelocity,t)}}class d{constructor(e=300,i=12,s=.84){this.minimumInitialVelocity=e,this.stopVelocity=i,this.friction=s,this.enabled=!0,this.time=new c(.6),this.screen=[new c(.4),new c(.4)],this.scene=[new c(.6),new c(.6),new c(.6)],this.tmpDirection=t()}add(t,e,i){if(this.enabled){if(this.time.hasLastValue){if(this.time.computeDelta(i)<.015)return}this.screen[0].update(t[0]),this.screen[1].update(t[1]),this.scene[0].update(e[0]),this.scene[1].update(e[1]),this.scene[2].update(e[2]),this.time.update(i)}}reset(){this.screen[0].reset(),this.screen[1].reset(),this.scene[0].reset(),this.scene[1].reset(),this.scene[2].reset(),this.time.reset()}evaluateMomentum(){if(!this.enabled||!this.screen[0].hasFilteredDelta)return null;const t=this.screen[0].filteredDelta,e=this.screen[1].filteredDelta,i=Math.sqrt(t*t+e*e)/this.time.filteredDelta;return Math.abs(i)<this.minimumInitialVelocity?null:this.createMomentum(i,this.stopVelocity,this.friction)}createMomentum(t,a,r){e(this.tmpDirection,this.scene[0].filteredDelta,this.scene[1].filteredDelta,this.scene[2].filteredDelta);const l=i(this.tmpDirection);l>0&&s(this.tmpDirection,this.tmpDirection,1/l);const n=l/this.time.filteredDelta;return new m(t,a,r,n,this.tmpDirection)}}class p{constructor(t=2.5,e=.01,i=.95,s=12){this.minimumInitialVelocity=t,this.stopVelocity=e,this.friction=i,this.maxVelocity=s,this.enabled=!0,this.value=new c(.8),this.time=new c(.3)}add(t,e){if(this.enabled){if(this.time.hasLastValue){if(this.time.computeDelta(e)<.01)return;if(this.value.hasFilteredDelta){const e=this.value.computeDelta(t);this.value.filteredDelta*e<0&&this.value.reset()}}this.time.update(e),this.value.update(t)}}reset(){this.value.reset(),this.time.reset()}evaluateMomentum(){if(!this.enabled||!this.value.hasFilteredDelta)return null;let t=this.value.filteredDelta/this.time.filteredDelta;return t=a(t,-this.maxVelocity,this.maxVelocity),Math.abs(t)<this.minimumInitialVelocity?null:this.createMomentum(t,this.stopVelocity,this.friction)}createMomentum(t,e,i){return new u(t,e,i)}}class f extends p{constructor(t=3,e=.01,i=.95,s=12){super(t,e,i,s)}add(t,e){if(this.value.hasLastValue){const e=this.value.lastValue;let i=t-e;for(;i>Math.PI;)i-=2*Math.PI;for(;i<-Math.PI;)i+=2*Math.PI;t=e+i}super.add(t,e)}}class v extends u{constructor(t,e,i){super(t,e,i)}value(t){const e=super.value(t);return Math.exp(e)}valueDelta(t,e){const i=super.value(t),s=super.value(t+e)-i;return Math.exp(s)}}class D extends p{constructor(t=2.5,e=.01,i=.95,s=12){super(t,e,i,s)}add(t,e){super.add(Math.log(t),e)}createMomentum(t,e,i){return new v(t,e,i)}}function V(t){if(!t)return null;const e=t.inverseTransform,i=t.transform,s=t.transformNoRotation,a=t.pixelRatio,o=[t.size[0],t.size[1]],h=t.viewpoint.targetGeometry,c=l(h.x,h.y);return{version:t.id,displayMat3:t.displayMat3.slice(),displayViewMat3:t.displayViewMat3.slice(),viewMat2d:t.viewMat2d.slice(),extent:t.extent.toJSON(),resolution:t.resolution,rotation:t.rotation,size:o,scale:t.scale,center:[h.x,h.y],spatialReference:t.spatialReference,pixelRatio:a,viewpoint:t.viewpoint,worldScreenWidth:t.worldScreenWidth,toMap:(t,i)=>r(t,i,e),toScreen:(t,e)=>r(t,e,i),toScreenNoRotation:(t,e)=>r(t,e,s),getScreenTransform:(t,e)=>(n(t,c,o,e,0,a),t)}}async function y(t){const e=import("./mask-svg.js"),i=import("./overlay-svg.js"),s=h((await e).default,{signal:t}),a=h((await i).default,{signal:t}),r={mask:await s,overlay:await a};return o(t),r}export{c as F,u as M,d as P,f as R,D as Z,V as c,y as l};

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{g as t}from"../geometry/SpatialReference.js";import{T as o}from"./TileKey.js";import{O as e}from"./ArrayPool.js";function s(t,o){return[t,o]}function l(t,o,e){return t[0]=o,t[1]=e,t}const r=new o("0/0/0/0");class i{constructor(t,o,e,s,l,r,i,n,a,h,c,u){this.level=t,this.resolution=o,this.scale=e,this.origin=s,this.first=l,this.last=r,this.size=i,this.norm=n,this.worldStart=a,this.worldEnd=h,this.worldSize=c,this.wrap=u}static create(o,e,r){const n=t(o.spatialReference),a=s(o.origin.x,o.origin.y),h=s(o.size[0]*e.resolution,o.size[1]*e.resolution),c=s(-1/0,-1/0),u=s(1/0,1/0),f=s(1/0,1/0);r&&(l(c,Math.max(0,Math.floor((r.xmin-a[0])/h[0])),Math.max(0,Math.floor((a[1]-r.ymax)/h[1]))),l(u,Math.max(0,Math.floor((r.xmax-a[0])/h[0])),Math.max(0,Math.floor((a[1]-r.ymin)/h[1]))),l(f,u[0]-c[0]+1,u[1]-c[1]+1));const{cols:m,rows:g}=e;let d,w,y,M;return!r&&m&&g&&(l(c,0,0),l(u,m-1,g-1),l(f,m,g)),o.isWrappable?(d=s(Math.ceil(Math.round((n.valid[1]-n.valid[0])/e.resolution)/o.size[0]),f[1]),w=s(Math.floor((n.origin[0]-a[0])/h[0]),c[1]),y=s(d[0]+w[0]-1,u[1]),M=!0):(w=c,y=u,d=f,M=!1),new i(e.level,e.resolution,e.scale,a,c,u,f,h,w,y,d,M)}normalizeCol(t){if(!this.wrap)return t;const o=this.worldSize[0];return t<0?o-1-Math.abs((t+1)%o):t%o}denormalizeCol(t,o){return this.wrap?this.worldSize[0]*o+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,o,e=!1){r.set(o);const s=e?r.col:this.denormalizeCol(r.col,r.world),l=r.row;return function(t,o,e,s,l){t[0]=o,t[1]=e,t[2]=s,t[3]=l}(t,this.getXForColumn(s),this.getYForRow(l+1),this.getXForColumn(s+1),this.getYForRow(l)),t}getTileCoords(t,o,e=!1){r.set(o);const s=e?r.col:this.denormalizeCol(r.col,r.world);return Array.isArray(t)?l(t,this.getXForColumn(s),this.getYForRow(r.row)):(t.x=this.getXForColumn(s),t.y=this.getYForRow(r.row)),t}}class n{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,o){const{spans:e,lodInfo:s}=this,{level:l}=s;if(0!==e.length)for(const{row:r,colFrom:i,colTo:n}of e)for(let e=i;e<=n;e++)t.call(o,l,r,s.normalizeCol(e),s.getWorldForColumn(e))}}n.pool=new e(n);class a{constructor(t,o,e){this.row=t,this.colFrom=o,this.colTo=e}}const h=new o("0/0/0/0");class c{constructor(t,o,e,s,l,r,i,n){this.x=t,this.ymin=o,this.ymax=e,this.invM=s,this.leftAdjust=l,this.rightAdjust=r,this.leftBound=i,this.rightBound=n}static create(t,o){t[1]>o[1]&&([t,o]=[o,t]);const[e,s]=t,[l,r]=o,i=l-e,n=r-s,a=0!==n?i/n:0,h=(Math.ceil(s)-s)*a,u=(Math.floor(s)-s)*a;return new c(e,Math.floor(s),Math.ceil(r),a,i<0?h:u,i<0?u:h,i<0?l:e,i<0?e:l)}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const u=[[0,0],[0,0],[0,0],[0,0]];class f{constructor(t,o){this.tileInfo=t,this.fullExtent=o,this.scales=[],this._lodInfos=null,this._infoByScale={},this._infoByLevel={};const e=t.lods.slice();e.sort((function(t,o){return o.scale-t.scale}));const s=this._lodInfos=e.map((e=>i.create(t,e,o)));e.forEach(((t,o)=>{this._infoByLevel[t.level]=s[o],this._infoByScale[t.scale]=s[o],this.scales[o]=t.scale}),this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel["number"==typeof t?t:t.level]}getTileBounds(t,o,e=!1){h.set(o);const s=this._infoByLevel[h.level];return s?s.getTileBounds(t,h,e):t}getTileCoords(t,o,e=!1){h.set(o);const s=this._infoByLevel[h.level];return s?s.getTileCoords(t,h,e):t}getTileCoverage(t,o=192,e="closest"){const s="closest"===e?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),l=n.pool.acquire(s),r=this._wrap;let i,h,f,m=1/0,g=-1/0;const d=l.spans;u[0][0]=u[0][1]=u[1][1]=u[3][0]=-o,u[1][0]=u[2][0]=t.size[0]+o,u[2][1]=u[3][1]=t.size[1]+o;for(const o of u)t.toMap(o,o),o[0]=s.getColumnForX(o[0]),o[1]=s.getRowForY(o[1]);const w=[];let y=3;for(let t=0;t<4;t++){if(u[t][1]===u[y][1]){y=t;continue}const o=c.create(u[t],u[y]);m=Math.min(o.ymin,m),g=Math.max(o.ymax,g),void 0===w[o.ymin]&&(w[o.ymin]=[]),w[o.ymin].push(o),y=t}if(null==m||null==g||g-m>100)return null;let M=[];for(i=m;i<g;){null!=w[i]&&(M=M.concat(w[i])),h=1/0,f=-1/0;for(let t=M.length-1;t>=0;t--){const o=M[t];h=Math.min(h,o.getLeftCol()),f=Math.max(f,o.getRightCol())}if(h=Math.floor(h),f=Math.floor(f),i>=s.first[1]&&i<=s.last[1])if(r)if(s.size[0]<s.worldSize[0]){const t=Math.floor(f/s.worldSize[0]);for(let o=Math.floor(h/s.worldSize[0]);o<=t;o++)d.push(new a(i,Math.max(s.getFirstColumnForWorld(o),h),Math.min(s.getLastColumnForWorld(o),f)))}else d.push(new a(i,h,f));else h>s.last[0]||f<s.first[0]||(h=Math.max(h,s.first[0]),f=Math.min(f,s.last[0]),d.push(new a(i,h,f)));i+=1;for(let t=M.length-1;t>=0;t--){const o=M[t];o.ymax>=i?o.incrRow():M.splice(t,1)}}return l}getTileParentId(t){h.set(t);const o=this._infoByLevel[h.level],e=this._lodInfos.indexOf(o)-1;return e<0?null:(this._getTileIdAtLOD(h,this._lodInfos[e],h),h.id)}getTileResolution(t){const o=this._infoByLevel["object"==typeof t?t.level:t];return o?o.resolution:-1}getTileScale(t){const o=this._infoByLevel[t.level];return o?o.scale:-1}intersects(t,o){h.set(o);const e=this._infoByLevel[h.level],s=t.lodInfo;if(s.resolution>e.resolution){this._getTileIdAtLOD(h,s,h);const o=s.denormalizeCol(h.col,h.world);for(const e of t.spans)if(e.row===h.row&&e.colFrom<=o&&e.colTo>=o)return!0}if(s.resolution<e.resolution){const[o,l,r,i]=t.spans.reduce(((t,o)=>(t[0]=Math.min(t[0],o.row),t[1]=Math.max(t[1],o.row),t[2]=Math.min(t[2],o.colFrom),t[3]=Math.max(t[3],o.colTo),t)),[1/0,-1/0,1/0,-1/0]),n=e.denormalizeCol(h.col,h.world),a=s.getColumnForX(e.getXForColumn(n)),c=s.getRowForY(e.getYForRow(h.row)),u=s.getColumnForX(e.getXForColumn(n+1))-1,f=s.getRowForY(e.getYForRow(h.row+1))-1;return!(a>i||u<r||c>l||f<o)}const l=s.denormalizeCol(h.col,h.world);return t.spans.some((t=>t.row===h.row&&t.colFrom<=l&&t.colTo>=l))}normalizeBounds(o,e,s){if(o[0]=e[0],o[1]=e[1],o[2]=e[2],o[3]=e[3],this._wrap){const e=t(this.tileInfo.spatialReference),l=-s*(e.valid[1]-e.valid[0]);o[0]+=l,o[2]+=l}return o}getSmallestInfoForScale(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>o[0])return this._infoByScale[o[0]];for(let e=1;e<o.length-1;e++)if(t>o[e]+1e-6)return this._infoByScale[o[e-1]];return this._infoByScale[o[o.length-1]]}getClosestInfoForScale(t){const o=this.scales;return this._infoByScale[t]||(t=o.reduce(((o,e)=>Math.abs(e-t)<Math.abs(o-t)?e:o),o[0])),this._infoByScale[t]}scaleToLevel(t){const o=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let e=o.length-1;e>=0;e--)if(t<o[e]){if(e===o.length-1)return this._infoByScale[o[o.length-1]].level;return this._infoByScale[o[e]].level+(o[e]-t)/(o[e]-o[e+1])}return this._infoByScale[o[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,o,e){const s=this._infoByLevel[e.level];return t.set(e),o.resolution<s.resolution?null:(o.resolution===s.resolution||(t.level=o.level,t.col=Math.floor(e.col*s.resolution/o.resolution+.01),t.row=Math.floor(e.row*s.resolution/o.resolution+.01)),t)}}export{f as T,n as a};

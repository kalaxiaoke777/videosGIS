// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.21/esri/copyright.txt for details.
//>>built
define(["exports","../views/3d/webgl-engine/core/shaderModules/interfaces","../views/3d/webgl-engine/core/shaderModules/ShaderBuilder"],function(b,d,e){function c(){const a=new e.ShaderBuilder;a.attributes.add("position","vec3");a.vertex.code.add(d.glsl`void main(void) {
gl_Position = vec4(position, 1.0);
}`);a.fragment.uniforms.add("tileRows","float").add("tileSize","float");a.fragment.code.add("\n    #define NUM_CELLS 2.0\n    #define PERLIN_WORLEY 0\n    #define WORLEY 1\n\n    float remap(float x, float low1, float high1, float low2, float high2) {\n      return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n    }\n\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }\n\n    vec4 taylorInvSqrt(vec4 r) {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n\n    vec4 mod289(vec4 x) {\n      return x - floor( x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec4 permute(vec4 x) {\n      return mod289(((x * 34.0) + 1.0) * x);\n    }\n\n    vec4 fade(vec4 t) {\n      return (t * t * t) * (t * (t * vec4(6) - vec4(15)) + vec4(10));\n    }\n\n    float glmPerlin(vec4 Position, vec4 rep) {\n      vec4 Pi0 \x3d mod(floor(Position), rep);\n      vec4 Pi1 \x3d mod(Pi0 + float(1), rep);\n      vec4 Pf0 \x3d fract(Position);\n      vec4 Pf1 \x3d Pf0 - float(1);\n      vec4 ix \x3d vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n      vec4 iy \x3d vec4(Pi0.y, Pi0.y, Pi1.y, Pi1.y);\n      vec4 iz0 \x3d vec4(Pi0.z);\n      vec4 iz1 \x3d vec4(Pi1.z);\n      vec4 iw0 \x3d vec4(Pi0.w);\n      vec4 iw1 \x3d vec4(Pi1.w);\n\n      vec4 ixy \x3d permute(permute(ix) + iy);\n      vec4 ixy0 \x3d permute(ixy + iz0);\n      vec4 ixy1 \x3d permute(ixy + iz1);\n      vec4 ixy00 \x3d permute(ixy0 + iw0);\n      vec4 ixy01 \x3d permute(ixy0 + iw1);\n      vec4 ixy10 \x3d permute(ixy1 + iw0);\n      vec4 ixy11 \x3d permute(ixy1 + iw1);\n\n      vec4 gx00 \x3d ixy00 / float(7);\n      vec4 gy00 \x3d floor(gx00) / float(7);\n      vec4 gz00 \x3d floor(gy00) / float(6);\n      gx00 \x3d fract(gx00) - float(0.5);\n      gy00 \x3d fract(gy00) - float(0.5);\n      gz00 \x3d fract(gz00) - float(0.5);\n      vec4 gw00 \x3d vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n      vec4 sw00 \x3d step(gw00, vec4(0));\n      gx00 -\x3d sw00 * (step(float(0), gx00) - float(0.5));\n      gy00 -\x3d sw00 * (step(float(0), gy00) - float(0.5));\n\n      vec4 gx01 \x3d ixy01 / float(7);\n      vec4 gy01 \x3d floor(gx01) / float(7);\n      vec4 gz01 \x3d floor(gy01) / float(6);\n      gx01 \x3d fract(gx01) - float(0.5);\n      gy01 \x3d fract(gy01) - float(0.5);\n      gz01 \x3d fract(gz01) - float(0.5);\n      vec4 gw01 \x3d vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n      vec4 sw01 \x3d step(gw01, vec4(0.0));\n      gx01 -\x3d sw01 * (step(float(0), gx01) - float(0.5));\n      gy01 -\x3d sw01 * (step(float(0), gy01) - float(0.5));\n\n      vec4 gx10 \x3d ixy10 / float(7);\n      vec4 gy10 \x3d floor(gx10) / float(7);\n      vec4 gz10 \x3d floor(gy10) / float(6);\n      gx10 \x3d fract(gx10) - float(0.5);\n      gy10 \x3d fract(gy10) - float(0.5);\n      gz10 \x3d fract(gz10) - float(0.5);\n      vec4 gw10 \x3d vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n      vec4 sw10 \x3d step(gw10, vec4(0.0));\n      gx10 -\x3d sw10 * (step(float(0), gx10) - float(0.5));\n      gy10 -\x3d sw10 * (step(float(0), gy10) - float(0.5));\n\n      vec4 gx11 \x3d ixy11 / float(7);\n      vec4 gy11 \x3d floor(gx11) / float(7);\n      vec4 gz11 \x3d floor(gy11) / float(6);\n      gx11 \x3d fract(gx11) - float(0.5);\n      gy11 \x3d fract(gy11) - float(0.5);\n      gz11 \x3d fract(gz11) - float(0.5);\n      vec4 gw11 \x3d vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n      vec4 sw11 \x3d step(gw11, vec4(float(0)));\n      gx11 -\x3d sw11 * (step(float(0), gx11) - float(0.5));\n      gy11 -\x3d sw11 * (step(float(0), gy11) - float(0.5));\n\n      vec4 g0000 \x3d vec4(gx00.x, gy00.x, gz00.x, gw00.x);\n      vec4 g1000 \x3d vec4(gx00.y, gy00.y, gz00.y, gw00.y);\n      vec4 g0100 \x3d vec4(gx00.z, gy00.z, gz00.z, gw00.z);\n      vec4 g1100 \x3d vec4(gx00.w, gy00.w, gz00.w, gw00.w);\n      vec4 g0010 \x3d vec4(gx10.x, gy10.x, gz10.x, gw10.x);\n      vec4 g1010 \x3d vec4(gx10.y, gy10.y, gz10.y, gw10.y);\n      vec4 g0110 \x3d vec4(gx10.z, gy10.z, gz10.z, gw10.z);\n      vec4 g1110 \x3d vec4(gx10.w, gy10.w, gz10.w, gw10.w);\n      vec4 g0001 \x3d vec4(gx01.x, gy01.x, gz01.x, gw01.x);\n      vec4 g1001 \x3d vec4(gx01.y, gy01.y, gz01.y, gw01.y);\n      vec4 g0101 \x3d vec4(gx01.z, gy01.z, gz01.z, gw01.z);\n      vec4 g1101 \x3d vec4(gx01.w, gy01.w, gz01.w, gw01.w);\n      vec4 g0011 \x3d vec4(gx11.x, gy11.x, gz11.x, gw11.x);\n      vec4 g1011 \x3d vec4(gx11.y, gy11.y, gz11.y, gw11.y);\n      vec4 g0111 \x3d vec4(gx11.z, gy11.z, gz11.z, gw11.z);\n      vec4 g1111 \x3d vec4(gx11.w, gy11.w, gz11.w, gw11.w);\n\n      vec4 norm00 \x3d taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n      g0000 *\x3d norm00.x;\n      g0100 *\x3d norm00.y;\n      g1000 *\x3d norm00.z;\n      g1100 *\x3d norm00.w;\n\n      vec4 norm01 \x3d taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n      g0001 *\x3d norm01.x;\n      g0101 *\x3d norm01.y;\n      g1001 *\x3d norm01.z;\n      g1101 *\x3d norm01.w;\n\n      vec4 norm10 \x3d taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n      g0010 *\x3d norm10.x;\n      g0110 *\x3d norm10.y;\n      g1010 *\x3d norm10.z;\n      g1110 *\x3d norm10.w;\n\n      vec4 norm11 \x3d taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n      g0011 *\x3d norm11.x;\n      g0111 *\x3d norm11.y;\n      g1011 *\x3d norm11.z;\n      g1111 *\x3d norm11.w;\n\n      float n0000 \x3d dot(g0000, Pf0);\n      float n1000 \x3d dot(g1000, vec4(Pf1.x, Pf0.y, Pf0.z, Pf0.w));\n      float n0100 \x3d dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.z, Pf0.w));\n      float n1100 \x3d dot(g1100, vec4(Pf1.x, Pf1.y, Pf0.z, Pf0.w));\n      float n0010 \x3d dot(g0010, vec4(Pf0.x, Pf0.y, Pf1.z, Pf0.w));\n      float n1010 \x3d dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n      float n0110 \x3d dot(g0110, vec4(Pf0.x, Pf1.y, Pf1.z, Pf0.w));\n      float n1110 \x3d dot(g1110, vec4(Pf1.x, Pf1.y, Pf1.z, Pf0.w));\n      float n0001 \x3d dot(g0001, vec4(Pf0.x, Pf0.y, Pf0.z, Pf1.w));\n      float n1001 \x3d dot(g1001, vec4(Pf1.x, Pf0.y, Pf0.z, Pf1.w));\n      float n0101 \x3d dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n      float n1101 \x3d dot(g1101, vec4(Pf1.x, Pf1.y, Pf0.z, Pf1.w));\n      float n0011 \x3d dot(g0011, vec4(Pf0.x, Pf0.y, Pf1.z, Pf1.w));\n      float n1011 \x3d dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.z, Pf1.w));\n      float n0111 \x3d dot(g0111, vec4(Pf0.x, Pf1.y, Pf1.z, Pf1.w));\n      float n1111 \x3d dot(g1111, Pf1);\n\n      vec4 fade_xyzw \x3d fade(Pf0);\n      vec4 n_0w \x3d mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n      vec4 n_1w \x3d mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n      vec4 n_zw \x3d mix(n_0w, n_1w, fade_xyzw.z);\n      vec2 n_yzw \x3d mix(vec2(n_zw.x, n_zw.y), vec2(n_zw.z, n_zw.w), fade_xyzw.y);\n      float n_xyzw \x3d mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n      return float(2.2) * n_xyzw;\n    }\n\n    float getPerlinNoise(vec3 pos, float frequency) {\n      const float octaveFrequencyFactor \x3d 2.0;\n\n      float sum \x3d 0.0;\n      float weightSum \x3d 0.0;\n      float weight \x3d 1.0;\n\n      for (int oct \x3d 0; oct \x3c 3; oct++) {\n        vec3 p \x3d pos * frequency;\n        float val \x3d 0.5 + 0.5 * glmPerlin(vec4(p, 0.0), vec4(frequency));\n        sum +\x3d val * weight;\n        weightSum +\x3d weight;\n        weight *\x3d 0.5;\n        frequency *\x3d octaveFrequencyFactor;\n      }\n\n      float noise \x3d (sum / weightSum);\n      noise \x3d saturate(noise);\n      return noise;\n    }\n\n    float hash(float p) {\n      p \x3d fract(p * 0.1031);\n      p *\x3d p + 33.33;\n      p *\x3d p + p;\n      return fract(p);;\n    }\n\n    float noise(vec3 x) {\n      vec3 p \x3d floor(x);\n      vec3 f \x3d fract(x);\n\n      f \x3d f * f * (3.0 - 2.0 * f);\n      float n \x3d p.x + p.y * 57.0 + 113.0 * p.z;\n\n      return mix(\n      mix(\n        mix(hash(n + 0.0), hash(n + 1.0), f.x),\n        mix(hash(n + 57.0), hash(n + 58.0), f.x),\n        f.y),\n      mix(\n        mix(hash(n + 113.0), hash(n + 114.0), f.x),\n        mix(hash(n + 170.0), hash(n + 171.0), f.x),\n        f.y),\n      f.z);\n    }\n\n    float worley(vec3 pos, float numCells) {\n      vec3 p \x3d pos * numCells;\n      float d \x3d 1.0e10;\n\n      for (int x \x3d -1; x \x3c\x3d 1; x++) {\n        for (int y \x3d -1; y \x3c\x3d 1; y++) {\n          for (int z \x3d -1; z \x3c\x3d 1; z++) {\n            vec3 tp \x3d floor(p) + vec3(x, y, z);\n            tp \x3d p - tp - noise(mod(tp, numCells));\n            d \x3d min(d, dot(tp, tp));\n          }\n        }\n      }\n\n      return 1.0 - clamp(d, 0.0, 1.0);\n    }\n\n    vec3 get3Dfrom2D(vec2 uv, float tileRows) {\n      vec2 tile \x3d floor(uv);\n      float z \x3d floor(tileRows * tile.y + tile.x);\n      return vec3(fract(uv), z);\n    }\n\n    float getTextureForPoint(vec3 p, int type) {\n      if (type \x3d\x3d PERLIN_WORLEY) {\n\n        const float frequency \x3d 8.0;\n        float perlinNoise \x3d getPerlinNoise(p, frequency);\n\n        float worley0 \x3d worley(p, NUM_CELLS * 2.0);\n        float worley1 \x3d worley(p, NUM_CELLS * 8.0);\n        float worley2 \x3d worley(p, NUM_CELLS * 14.0);\n\n        float worleyFBM \x3d worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n        return remap(perlinNoise, 0.0, 1.0, worleyFBM, 1.0);\n      }\n\n      float worley0 \x3d worley(p, NUM_CELLS);\n      float worley1 \x3d worley(p, NUM_CELLS * 2.0);\n      float worley2 \x3d worley(p, NUM_CELLS * 4.0);\n      float worley3 \x3d worley(p, NUM_CELLS * 8.0);\n\n      float FBM0 \x3d worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n      float FBM1 \x3d worley1 * 0.625 + worley2 * 0.25 + worley3 * 0.125;\n      float FBM2 \x3d worley2 * 0.75 + worley3 * 0.25;\n\n      return FBM0 * 0.625 + FBM1 * 0.25 + FBM2 * 0.125;\n    }\n  ");
a.fragment.code.add("\n    void main() {\n      const float padWidth \x3d 1.0;\n      float paddedSize \x3d tileSize + 2.0 * padWidth;\n      float tileCount \x3d tileRows * tileRows;\n      vec2 tile \x3d floor((gl_FragCoord.xy - 0.5) / paddedSize);\n\n      bool padCell \x3d false;\n      if (mod(gl_FragCoord.x, paddedSize) \x3d\x3d 0.5 || mod(gl_FragCoord.x, paddedSize) \x3d\x3d paddedSize - 0.5) {\n        padCell \x3d true;\n      }\n\n      if (mod(gl_FragCoord.y, paddedSize) \x3d\x3d 0.5 || mod(gl_FragCoord.y, paddedSize) \x3d\x3d paddedSize - 0.5) {\n        padCell \x3d true;\n      }\n\n      bool startPadX \x3d false;\n      bool startPadY \x3d false;\n      bool endPadX \x3d false;\n      bool endPadY \x3d false;\n\n      if (gl_FragCoord.x \x3d\x3d tile.x * paddedSize + 0.5) {\n        startPadX \x3d true;\n      }\n\n      if (gl_FragCoord.y \x3d\x3d tile.y * paddedSize + 0.5) {\n        startPadY \x3d true;\n      }\n\n      if (gl_FragCoord.x \x3d\x3d (tile.x + 1.0) * paddedSize - 0.5) {\n        endPadX \x3d true;\n      }\n\n      if (gl_FragCoord.y \x3d\x3d (tile.y + 1.0) * paddedSize - 0.5) {\n        endPadY \x3d true;\n      }\n\n      vec2 padding \x3d vec2(2.0 * padWidth) * tile;\n      vec2 uv;\n\n      if (padCell) {\n        vec2 pixel \x3d gl_FragCoord.xy - padWidth - padding;\n\n        if (startPadX) {\n          pixel.x +\x3d tileSize;\t\n        }\n\n        if (startPadY) {\n          pixel.y +\x3d tileSize;\t\n        }\n\n        if (endPadX) {\n          pixel.x -\x3d tileSize;\t\n        }\n\n        if (endPadY) {\n          pixel.y -\x3d tileSize;\t\n        }\n\n        uv \x3d vec2(pixel.xy / tileSize);\n      } else {\n        vec2 pixel \x3d gl_FragCoord.xy - padWidth - padding;\n        uv \x3d vec2(pixel.xy / tileSize);\n      }\n\n      vec3 p_ \x3d get3Dfrom2D(uv, tileRows);\n      vec3 p \x3d p_;\n      p.z /\x3d (tileRows * tileRows);\n\n      float worleyPerlinNoise \x3d getTextureForPoint(p, PERLIN_WORLEY);\n      float worleyNoise \x3d getTextureForPoint(p, WORLEY);\n\n      vec3 col \x3d vec3(0);\n      col.r \x3d saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n      p_ \x3d mod(p_ + 1.0, tileRows * tileRows);\n      p \x3d p_;\n      p.z /\x3d (tileRows * tileRows);\n\n      worleyPerlinNoise \x3d getTextureForPoint(p, PERLIN_WORLEY);\n      worleyNoise \x3d getTextureForPoint(p, WORLEY);\n\n      col.g \x3d saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n    \tgl_FragColor \x3d vec4(col, 1.0);\n    }\n  ");
return a}var f=Object.freeze({__proto__:null,build:c});b.NoiseTextureAtlasShader=f;b.build=c});
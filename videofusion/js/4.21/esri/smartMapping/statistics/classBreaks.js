// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.21/esri/copyright.txt for details.
//>>built
define("../../chunks/_rollupPluginBabelHelpers ../../core/Error ../../core/maybe ./support/utils ../support/utils ../support/adapters/support/layerUtils".split(" "),function(p,b,w,q,r,f){function x(a){return g.apply(this,arguments)}function g(){g=p._asyncToGenerator(function*(a){if(!a||!a.layer||!a.field&&!a.valueExpression)throw new b("class-breaks:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(a.valueExpression&&!a.view)throw new b("class-breaks:missing-parameters",
"View is required when 'valueExpression' is specified");const {layer:h,...k}=a;var c=f.createLayerAdapter(h,f.featureCapableLayerTypes);a={layerAdapter:c,...k};a.normalizationType=r.getNormalizationType(a);a.numClasses=a.numClasses||5;if(!c)throw new b("class-breaks:invalid-parameters","'layer' must be one of these types: "+f.getLayerTypeLabels(f.featureCapableLayerTypes).join(", "));var d=w.isSome(a.signal)?{signal:a.signal}:null;yield c.load(d);var e=a.field;d=a.minValue;const l=a.maxValue,y=null!=
d||null!=l,t=a.classificationMethod,u="percent-of-total"===a.normalizationType,v=!1!==a.analyzeData;e=e?c.getField(e):null;var m=yield r.getFieldsList({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression});if(m=q.verifyBasicFieldValidity(c,m,"class-breaks:invalid-parameters"))throw m;if(e&&(c=q.verifyNumericField(c,e,"class-breaks:invalid-parameters")))throw c;if(a.valueExpression&&a.normalizationType)throw new b("class-breaks:invalid-parameters","Normalization is not allowed when 'valueExpression' is specified");
if(y)if(v){if(u&&null==a.normalizationTotal)throw new b("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'minValue', 'maxValue' are specified");}else{if(null==d||null==l)throw new b("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");if(d>=l)throw new b("class-breaks:invalid-parameters","'minValue' should be less than 'maxValue'");if(t&&"equal-interval"!==t)throw new b("class-breaks:invalid-parameters",
"'classificationMethod' other than 'equal-interval' is not allowed when 'analyzeData' is false");if(u&&null==a.normalizationTotal)throw new b("class-breaks:missing-parameters","'normalizationTotal' is required when 'normalizationType' is 'precent-of-total' and 'analyzeData' is false");}else if(!v)throw new b("class-breaks:missing-parameters","Both 'minValue' and 'maxValue' are required when 'analyzeData' is false");return a});return g.apply(this,arguments)}function n(){n=p._asyncToGenerator(function*(a){const {layerAdapter:h,
...k}=yield x(a);return h.classBreaks(k)});return n.apply(this,arguments)}return function(a){return n.apply(this,arguments)}});
// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.21/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../geometry ../../../core/arrayUtils ../../../core/Error ../../../core/Logger ../../../core/maybe ../../../core/promiseUtils ../../../core/watchUtils ../../../core/accessorSupport/decorators/property ../../../core/has ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/subclass ../../../geometry/support/quantizationUtils ../../../geometry/support/spatialReferenceUtils ../../../layers/support/arcgisLayerUrl ../../../layers/support/fieldUtils ../../../rest/support/GenerateRendererParameters ../../../rest/support/QuantizationParameters ../../../rest/support/StatisticDefinition ../../../rest/support/UniqueValueDefinition ../../statistics/support/predominanceUtils ../../statistics/support/utils ../../statistics/support/WorkerClient ../utils ./LayerAdapter ./support/utils ../../../tasks/GenerateRendererTask ../../../geometry/Point".split(" "),
function(x,I,C,J,v,P,E,A,Q,R,ba,ca,S,K,L,T,B,F,U,G,V,M,u,W,N,X,p,Y,Z){const aa=P.getLogger("esri.smartMapping.support.adapters.FeatureLayerAdapter");C=function(O){function H(a){return O.call(this,a)||this}x._inheritsLoose(H,O);var m=H.prototype;m.destroy=function(){var a;this._hasLocalSource=null;null==(a=this.workerClient)?void 0:a.destroy()};m._isStatsSupportedOnService=function(){const a=this.layer;return!a.get("capabilities.query.supportsStatistics")||"multipatch"===this.geometryType&&!T.isHostedAgolService(a.url)&&
10.5>a.version?Promise.reject(new v("feature-layer-adapter:not-supported","Layer does not support statistics query")):Promise.resolve()};m._waitForLayerViewUpdate=function(){var a=x._asyncToGenerator(function*(b){if(!b)throw new v("feature-layer-adapter:insufficient-data","layerView is required to fetch the features");const c=A.createAbortController();b=Q.whenFalseOnce(b,"updating",c.signal);yield A.timeout(b,5E3,c).catch(d=>{aa.warn("LayerView is taking too long to update. Aborting fetch from layerView.");
throw d;})});return function(b){return a.apply(this,arguments)}}();m._fetchFeaturesFromMemory=function(){var a=x._asyncToGenerator(function*(b,c,d,e){const h=this.layer;e="json"===e;if(this._hasLocalSource)return b=yield h.queryFeatures(c),e?p.ensureFeaturesJSON(b.features):b.features;yield this._waitForLayerViewUpdate(b);if(e&&"queryFeaturesJSON"in b&&b.queryFeaturesJSON)return{features:e}=yield b.queryFeaturesJSON(c,{signal:d}),e;b=yield b.queryFeatures(c,{signal:d});return e?p.ensureFeaturesJSON(b.features):
b.features});return function(b,c,d,e){return a.apply(this,arguments)}}();m._fetchFeaturesFromService=function(a,b){return this.layer.queryFeatures(a,{signal:b}).then(c=>c.features)};m._fetchFeaturesJSONFromService=function(a,b){return this._fetchFeaturesFromService(a,b).then(p.ensureFeaturesJSON)};m._fetchFeaturesForStats=function(a,b){return N.getFieldsList({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}).then(c=>this.getSampleFeatures({sampleSize:-1,view:a.view,
returnGeometry:a.returnGeometry,requiredFields:c,signal:a.signal},b))};m._summaryStatsFromGenRend=function(a){const b=a.normalizationType,c=a.normalizationField;return this.classBreaks({field:a.field,numClasses:5,classificationMethod:"standard-deviation",standardDeviationInterval:.25,normalizationType:b,normalizationField:"field"===b?c:void 0,minValue:a.minValue,maxValue:a.maxValue,signal:a.signal}).then(d=>{let e,h;d.classBreakInfos.some(f=>{f.hasAvg&&(e=f);return!!e});if(e){var k=e.maxValue-e.minValue;
h=e.minValue+k/2;k*=4}return p.processSummaryStatisticsResult({min:d.minValue,max:d.maxValue,avg:h,stddev:k})})};m._getSummaryStatsQuery=function(a,b){const {field:c,normalizationType:d,normalizationField:e,normalizationTotal:h,minValue:k,maxValue:f}=a;b=this.supportsSQLExpression&&b?p.msSinceUnixEpochSQL(this,c):a.sqlExpression;var g=p.getFieldExpr({field:c,normalizationType:d,normalizationField:e,normalizationTotal:h,layer:this});const l=b||g;g=l?u.getRangeExpr(l,k,f):null;var n=u.getSQLFilterForNormalization({field:c,
normalizationField:e,normalizationType:d});a=u.mergeWhereClauses(a.sqlWhere,n);a=u.mergeWhereClauses(a,g);const t=u.isNullCountSupported({normalizationField:e,normalizationType:d,sqlExpression:b,supportsSQLExpression:this.supportsSQLExpression,minValue:k,maxValue:f}),q=B.isStringField(this.getField(c));g=p.statisticTypes.filter(r=>"nullcount"===r?t:q?"count"===r:!0);n=this.layer.createQuery();n.where=u.mergeWhereClauses(n.where,a);n.sqlFormat=b?"standard":null;n.outStatistics=g.map(r=>{const w=new G;
let z=null,y=null,D=`${r}_value`;"variance"===r?(z="var",y=l):"nullcount"===r?(z="count",y=this.layer.objectIdField,D="totalcount_value"):(z=r,y=l);w.statisticType=z;w.onStatisticField=y;w.outStatisticFieldName=D;return w});return n};m._summaryStatsFromServiceQuery=function(){var a=x._asyncToGenerator(function*(b,c){yield this._isStatsSupportedOnService();"percent-of-total"===b.normalizationType&&(b.normalizationTotal=yield this._getNormalizationTotal(b.field,b.normalizationType));const d=this._getSummaryStatsQuery(b,
c);b=yield this.layer.queryFeatures(d,{signal:b.signal});c=p.getSummaryStatisticsFromFeatureSet(b,c);return p.processSummaryStatisticsResult(c)});return function(b,c){return a.apply(this,arguments)}}();m._summaryStatsFromClientQuery=function(){var a=x._asyncToGenerator(function*(b,c){const d=this._getSummaryStatsQuery(b,c);b=yield this.layer.queryFeatures(d,{signal:b.signal});c=p.getSummaryStatisticsFromFeatureSet(b,c);return p.processSummaryStatisticsResult(c)});return function(b,c){return a.apply(this,
arguments)}}();m._summaryStatsFromMemory=function(){var a=x._asyncToGenerator(function*(b,c){const {view:d,field:e,normalizationType:h,features:k,signal:f}=b;if(k){var g={...b};if("percent-of-total"===h){b=(yield p.calculateStatsFromMemory({field:e},k)).sum;if(null==b)throw new v("feature-layer-adapter:invalid","invalid normalizationTotal");g.normalizationTotal=b}c=yield p.calculateStatsFromMemory(g,k,"date"===(null==c?void 0:c.type));return p.processSummaryStatisticsResult(c)}const {featuresJSON:l,
layerView:n,query:t}=yield this._processStatsFromMemoryParams(b);g={field:e,valueExpression:b.valueExpression,normalizationType:b.normalizationType,normalizationField:b.normalizationField,normalizationTotal:b.normalizationTotal,minValue:b.minValue,maxValue:b.maxValue};if(b.valueExpression&&d&&l){var q;g.fieldType=null==c?void 0:c.type;g.viewInfoParams={viewingMode:"2d"===d.type?"map":d.viewingMode,scale:d.scale,spatialReference:null==(q=d.spatialReference)?void 0:q.toJSON()}}if("percent-of-total"===
h&&null==b.normalizationTotal){c=(!l&&n&&"querySummaryStatistics"in n&&n.querySummaryStatistics?yield n.querySummaryStatistics(t,{field:e},{signal:f}):yield this.workerClient.summaryStatistics({field:e},l)).sum;if(null==c)throw new v("feature-layer-adapter:invalid","invalid normalizationTotal");g.normalizationTotal=c}c=!l&&n&&"querySummaryStatistics"in n&&n.querySummaryStatistics?yield n.querySummaryStatistics(t,g,{signal:f}):yield this.workerClient.summaryStatistics(g,l);return p.processSummaryStatisticsResult(c)});
return function(b,c){return a.apply(this,arguments)}}();m._processStatsFromMemoryParams=function(){var a=x._asyncToGenerator(function*(b){if(!b.view)throw new v("feature-layer-adapter:insufficient-data","View is required to fetch the features");const {view:c,field:d,normalizationField:e,valueExpression:h,signal:k}=b;b=yield c.whenLayerView(this.layer);let f="querySummaryStatistics"in b&&"function"===typeof b.querySummaryStatistics,g=null,l=null;if(f)try{yield this._waitForLayerViewUpdate(b);const t=
yield N.getFieldsList({field:d,normalizationField:e,valueExpression:h});(yield p.getMissingFields(this,t,b)).length?f=!1:(g=this.layer.createQuery(),g.outFields=t,g.returnGeometry=!1);b.suspended&&(f=!1)}catch{f=!1}if(!f){var n;l=yield this._fetchFeaturesForStats({field:d,valueExpression:h,normalizationField:e,view:c,signal:k},"json");if(null==(n=l)||!n.length)throw new v("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");}return{layerView:b,query:g,featuresJSON:l}});
return function(b){return a.apply(this,arguments)}}();m._uvFromGenRenderer=function(a,b){const c=a.field,d=new V;d.attributeField=c;const e=new F;e.classificationDefinition=d;return this.generateRenderer(e,a.signal).then(h=>{const k={},f=this.getField(c);h.uniqueValues.forEach(g=>{let l=g.value;if(null==l||""===l||"string"===typeof l&&(""===l.trim()||"\x3cnull\x3e"===l.toLowerCase()))l=null;null==k[l]?k[l]={count:g.count,data:B.isNumericField(f)&&l?Number(l):l}:k[l].count+=g.count});return{count:k}}).then(h=>
p.createUVResult(h,b,a.returnAllCodedValues))};m._getUVQuery=function(a){const b=a.field,c=a.sqlExpression;var d="countOF"+(b||"Expr");const e=new G;e.statisticType="count";e.onStatisticField=c?"1":b;e.outStatisticFieldName=d;d=this.layer.createQuery();d.where=u.mergeWhereClauses(d.where,a.sqlWhere);d.sqlFormat=c?"standard":null;d.outStatistics=[e];d.groupByFieldsForStatistics=[b||c];return d};m._uvFromServiceQuery=function(a,b){return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(this._getUVQuery(a),
{signal:a.signal})).then(c=>p.getUniqueValuesFromFeatureSet(c,this,a.field,a.view,null,a.signal)).then(c=>p.createUVResult(c,b,a.returnAllCodedValues))};m._uvFromClientQuery=function(){var a=x._asyncToGenerator(function*(b,c){var {signal:d}=b,e=this._getUVQuery(b);e=yield this.layer.queryFeatures(e,{signal:d});d=yield p.getUniqueValuesFromFeatureSet(e,this,b.field,b.view,null,d);return p.createUVResult(d,c,b.returnAllCodedValues)});return function(b,c){return a.apply(this,arguments)}}();m._uvFromMemory=
function(){var a=x._asyncToGenerator(function*(b,c){const {field:d,valueExpression:e,view:h,signal:k}=b;var f={field:d,valueExpression:e,view:h,signal:k};f=b.features?b.features:yield this._fetchFeaturesForStats(f);return p.calculateUniqueValuesFromMemory(b,f,c)});return function(b,c){return a.apply(this,arguments)}}();m._calcBinsSQL=function(a,b,c){const d=[],e=b.length;b.forEach((h,k)=>{const [f,g]=h;h=null;h=0!==k||c?k!==e-1||c?u.mergeWhereClauses(`${a} >= ${f}`,`${a} ${k===e-1?" \x3c\x3d ":" \x3c "} ${g}`):
`${a} >= ${f}`:`${a} < ${g}`;d.push("WHEN ("+h+") THEN "+(k+1))});return["CASE",d.join(" "),"ELSE 0 END"].join(" ")};m._getNormalizationTotal=function(a,b,c){return a&&"percent-of-total"===b?this.summaryStatistics({field:a,signal:c}).then(d=>d.sum):Promise.resolve(null)};m._getQueryParamsForExpr=function(a,b){const c=a.signal;if(!a.valueExpression&&!a.sqlExpression){const {field:e,normalizationType:h,normalizationField:k}=a;var d=e?this.getField(e):null;d=B.isDateField(d);b={field:e,normalizationType:h,
normalizationField:k,normalizationTotal:b,layer:this};return{sqlExpression:d?p.msSinceUnixEpochSQL(this,e):p.getFieldExpr(b),sqlWhere:d?null:a.sqlWhere||u.getSQLFilterForNormalization({field:e,normalizationType:h,normalizationField:k}),signal:c}}return{valueExpression:a.valueExpression,sqlExpression:a.sqlExpression,sqlWhere:a.sqlWhere,signal:c}};m._getDataRange=function(a,b,c){return null!=b&&null!=c?Promise.resolve({min:b,max:c}):this.summaryStatistics(a).then(d=>({min:d.min,max:d.max}))};m._histogramForExpr=
function(a){return this._getNormalizationTotal(a.field,a.normalizationType,a.signal).then(b=>{const c=this._getQueryParamsForExpr(a,b);return this._getDataRange(c,a.minValue,a.maxValue).then(d=>{const {min:e,max:h}=d,k=a.numBins||10;d=p.getEqualIntervalBins(e,h,k);d=this._calcBinsSQL(c.sqlExpression,d,null!=a.minValue&&null!=a.maxValue);const f=new G({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),g=this.layer.createQuery();g.where=u.mergeWhereClauses(g.where,c.sqlWhere);
g.sqlFormat="standard";g.outStatistics=[f];g.groupByFieldsForStatistics=[d];g.orderByFields=[d];return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(g,{signal:c.signal})).then(l=>p.getHistogramFromFeatureSet(l,e,h,k,b))})})};m._histogramForField=function(a){let b=null;b=null!=a.minValue&&null!=a.maxValue?Promise.resolve({min:a.minValue,max:a.maxValue}):this.summaryStatistics(a).then(c=>{if(!c.count)throw new v("feature-layer-adapter:insufficient-data","Either the layer has no features or none of the features have data for the field");
return{min:c.min,max:c.max}});return b.then(c=>this._getBins({min:c.min,max:c.max},a.field,a.numBins,a.view,a.signal))};m._getBins=function(a,b,c=10,d,e){const {min:h,max:k,normTotal:f,excludeZerosExpr:g}=a,l=a.intervals||p.getEqualIntervalBins(h,k,c);return this._queryBins(l,a.sqlExpr||b,g,d,e).then(n=>({bins:n.map((t,q)=>({minValue:l[q][0],maxValue:l[q][1],count:t.value})),minValue:h,maxValue:k,normalizationTotal:f}))};m._queryBins=function(a,b,c,d,e){const h=[],k=a.length;for(let f=0;f<k;f++){const g=
u.mergeWhereClauses(c,u.mergeWhereClauses(b+" \x3e\x3d "+a[f][0],null!==a[f][1]?b+(f===k-1?" \x3c\x3d ":" \x3c ")+a[f][1]:""));h.push(g)}return A.eachAlways(h.map(f=>this.queryFeatureCount({whereClause:f,view:d,signal:e})))};m._binParamsFromGenRend=function(a,b){const {field:c,normalizationType:d,normalizationField:e,signal:h}=a,k=u.getSQLFilterForNormalization({field:c,normalizationType:d,normalizationField:e});a=new F({classificationDefinition:p.createCBDefn({field:c,normalizationType:d,normalizationField:e,
classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,breakCount:a.numBins||10}),where:u.mergeWhereClauses(k,b)});return this.generateRenderer(a,h).then(f=>{const {normalizationTotal:g,classBreaks:l}=f;return p.generateBinParams({field:c,normalizationType:d,normalizationField:e,normalizationTotal:g,classBreaks:l,where:k,layer:this})})};m._histogramFromMemory=function(a){const {field:b,normalizationField:c,normalizationType:d,valueExpression:e,classificationMethod:h,
minValue:k,maxValue:f,view:g,signal:l}=a,n={field:b,valueExpression:e,normalizationField:c,view:g,signal:l};return(a.features?Promise.resolve(a.features):this._fetchFeaturesForStats(n)).then(t=>{if(!t||!t.length)throw new v("feature-layer-adapter:insufficient-data","No features are available to calculate histogram");var q=null!=k&&null!=f;let r=null;h&&"equal-interval"!==h||d?(q={...a},q.features=t,r=this._getBinParamsFromMemory(q)):r=q?Promise.resolve({min:k,max:f,source:"parameters"}):this.summaryStatistics({field:b,
valueExpression:e,features:t,view:g,signal:l}).then(w=>w.count?{min:w.min,max:w.max}:Promise.reject(new v("feature-layer-adapter:insufficient-data","No features are available to calculate histogram")));return r.then(w=>p.calculateHistogramFromMemory(a,w,t))})};m._getBinParamsFromMemory=function(){var a=x._asyncToGenerator(function*(b){const {field:c,valueExpression:d,classificationMethod:e,standardDeviationInterval:h,normalizationType:k,normalizationField:f,minValue:g,maxValue:l,features:n,view:t,
signal:q}=b;return this._classBreaksFromMemory({field:c,valueExpression:d,normalizationType:k,normalizationField:f,classificationMethod:e,standardDeviationInterval:h,minValue:g,maxValue:l,numClasses:b.numBins,features:n,view:t,signal:q}).then(r=>{const w=r.normalizationTotal;r=r.classBreakInfos;const z=u.getSQLFilterForNormalization({field:c,normalizationType:k,normalizationField:f});return p.generateBinParams({field:c,normalizationType:k,normalizationField:f,normalizationTotal:w,classBreaks:r,where:z,
layer:this})})});return function(b){return a.apply(this,arguments)}}();m._classBreaksFromGenRend=function(a){const {field:b,normalizationType:c,normalizationField:d,normalizationTotal:e,signal:h}=a,k=u.getSQLFilterForNormalization({field:b,normalizationType:c,normalizationField:d});var f=p.getFieldExpr({field:b,normalizationType:c,normalizationField:d,normalizationTotal:e,layer:this});f=u.getRangeExpr(f,a.minValue,a.maxValue);const g=p.createCBDefn({field:b,normalizationType:c,normalizationField:d,
classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,breakCount:a.numClasses||5}),l=new F;l.classificationDefinition=g;l.where=u.mergeWhereClauses(k,f);return this.generateRenderer(l,h).then(n=>p.resolveCBResult(a,n))};m._classBreaksFromInterpolation=function(a){const {minValue:b,maxValue:c}=a,d=a.numClasses||5,e=[],h=(c-b)/d;for(let k=0;k<d;k++){const f=b+k*h;e.push({minValue:f,maxValue:f+h})}e[d-1].maxValue=c;a=p.resolveCBResult(a,{classBreaks:e,normalizationTotal:a.normalizationTotal});
return Promise.resolve(a)};m._classBreaksFromMemory=function(){var a=x._asyncToGenerator(function*(b){const {field:c,normalizationField:d,valueExpression:e,view:h,signal:k}=b;var f={field:c,valueExpression:e,normalizationField:d,view:h,signal:k};f=b.features||(yield this._fetchFeaturesForStats(f));if(!f||!f.length)throw new v("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");b={...b};if("percent-of-total"===b.normalizationType){const g=(yield p.calculateStatsFromMemory({field:c},
f)).sum;if(null==g)throw new v("feature-layer-adapter:invalid","invalid normalizationTotal");b.normalizationTotal=g}return p.calculateClassBreaksFromMemory(b,f)});return function(b){return a.apply(this,arguments)}}();m._heatmapStatsFromMemory=function(){var a=x._asyncToGenerator(function*(b,c){const {blurRadius:d,field:e,view:h,signal:k}=b,{resolution:f,size:g}=h.state,l=new U({extent:h.extent,tolerance:f});b=this._quantizeFeatures(b.features||(yield this._fetchFeaturesForStats({field:e,view:h,returnGeometry:!0,
signal:k})),l,h);if(!b||!b.length)return{count:0,min:null,max:null,avg:null,stddev:null};if(c=p.calculateHeatmapStats(b,d,c,e,g[0],g[1]))return{count:c.count,min:c.min,max:c.max,avg:c.mean,stddev:c.stdDev};throw new v("feature-layer-adapter:invalid","unable to calculate heatmap statistics");});return function(b,c){return a.apply(this,arguments)}}();m._quantizeFeatures=function(a,b,c){const d=K.toQuantizationTransform(b),{spatialReference:e,size:h}=c,k=L.isWrappable(e)?L.getInfo(e):null,f=k?Math.round((k.valid[1]-
k.valid[0])/d.scale[0]):null;return a.map(g=>{const l=new Z(E.unwrap(g.geometry));K.quantizePoint(d,l,l,l.hasZ,l.hasM);g.geometry=k?this._wrapPoint(l,f,h[0]):l;return g})};m._wrapPoint=function(a,b,c){0>a.x?a.x+=b:a.x>c&&(a.x-=b);return a};m.getField=function(a=""){return this.layer.getField(a)};m.getFieldUsageInfo=function(a){return this.getField(a)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null};m.getFieldDomain=function(a,
b){return this.layer.getFieldDomain(a,b)};m.summaryStatistics=function(a){const {field:b,normalizationType:c,sqlExpression:d,view:e,features:h}=a,k=b?this.getField(b):null,f=B.isDateField(k),g=a.valueExpression||d,l=g&&!d,n=e&&"3d"===e.type;return this._hasLocalSource||h||l?l||h||n?this._summaryStatsFromMemory(a,k):this._summaryStatsFromClientQuery(a,f):this.supportsSQLExpression||!f&&!g&&"natural-log"!==c&&"square-root"!==c?(c&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(a):this._summaryStatsFromServiceQuery(a,
f)).catch(()=>{A.throwIfAborted(a.signal);return this._summaryStatsFromMemory(a,k)}):Promise.reject(new v("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries"))};m.uniqueValues=function(a){const {field:b,valueExpression:c,sqlExpression:d,signal:e}=a,h=(b?this.getField(b):null)&&this.getFieldDomain(b),k=c&&(!d||!this.supportsSQLExpression),f=a.view,g=f&&"3d"===f.type;return this._hasLocalSource||a.features||k?k||a.features||g?this._uvFromMemory(a,h):
this._uvFromClientQuery(a,h):this._uvFromServiceQuery(a,h).catch(l=>{A.throwIfAborted(e);return a.field?this._uvFromGenRenderer(a,h):l}).catch(()=>{A.throwIfAborted(e);return k||a.features||g?this._uvFromMemory(a,h):this._uvFromClientQuery(a,h)})};m.histogram=function(a){const {field:b,normalizationType:c,normalizationField:d,classificationMethod:e,view:h,signal:k}=a;var f=b?this.getField(b):null;f=B.isDateField(f);const g=a.valueExpression||a.sqlExpression,l=g&&!a.sqlExpression,n=this.supportsSQLExpression,
t=!e||"equal-interval"===e,q=a.minValue,r=a.maxValue,w=null!=q&&null!=r,z=a.numBins||10;return this._hasLocalSource||a.features||l?this._histogramFromMemory(a):(g||n)&&t?n||!g&&"natural-log"!==c&&"square-root"!==c?this._histogramForExpr(a):Promise.reject(new v("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries")):f&&t?Promise.reject(new v("feature-layer-adapter:not-supported","Normalization and date field are not allowed when layer does not support standardized SQL expression for queries")):
c||!t?this._binParamsFromGenRend(a).then(y=>{if(!w)return this._getBins(y,b,z,h,k);if(q>y.max||r<y.min)throw new v("histogram:insufficient-data","Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");if(t)return this._getBins({min:q,max:r,sqlExpr:y.sqlExpr,excludeZerosExpr:y.excludeZerosExpr},b,z,h,k);y=p.getFieldExpr({field:b,normalizationType:c,normalizationField:d,normalizationTotal:y.normTotal,layer:this});y=u.getRangeExpr(y,q,r);return this._binParamsFromGenRend(a,
y).then(D=>this._getBins(D,b,z,h,k))}):this._histogramForField(a)};m.classBreaks=function(a){const b=!1!==a.analyzeData,c=this._hasLocalSource||a.features||a.valueExpression;return b&&c?this._classBreaksFromMemory(a):(b?this._classBreaksFromGenRend(a):this._classBreaksFromInterpolation(a)).catch(()=>{A.throwIfAborted(a.signal);return this._classBreaksFromMemory(a)})};m.queryFeatureCount=function(a){if(this._hasLocalSource)return Promise.reject(new v("feature-layer-adapter:not-supported","Layer does not support count query"));
const b=this.layer,c=b.createQuery();c.where=u.mergeWhereClauses(c.where,a.whereClause);return b.queryFeatureCount(c,{signal:a.signal})};m.generateRenderer=function(a,b){var c=this.layer;if(this._hasLocalSource||10.1>c.version)return Promise.reject(new v("feature-layer-adapter:not-supported","Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)"));const d=new Y({url:c.parsedUrl.path,source:c.dynamicDataSource,gdbVersion:c.gdbVersion});c=c.createQuery();a.where=
u.mergeWhereClauses(a.where,c.where);return d.execute(a,{signal:b})};m.heatmapStatistics=function(a){const {field:b,fieldOffset:c,signal:d}=a;return(b&&null==c?this.summaryStatistics({field:b,signal:d}):Promise.resolve(null)).then(e=>{let h=c||0;if(e){const {count:k,min:f,max:g}=e;k?f===g&&0===f?h=1:0>=g?h="abs":0>f&&(h=-1.01*f):h=1}return this._heatmapStatsFromMemory(a,h).then(k=>({...k,summaryStatistics:e,fieldOffset:h}))})};m.predominantCategories=function(){var a=x._asyncToGenerator(function*(b){if(!this._hasLocalSource&&
!this.supportsSQLExpression)throw new v("feature-layer-adapter:not-supported","Layer does not support advanced SQL expressions and standardized queries");const {fields:c,view:d,signal:e}=b;b=M.getArcadeForPredominantCategory(c);const h=M.getSQLForPredominantCategoryName(c);b=d&&this._hasLocalSource?yield this._uvFromMemory({valueExpression:b,view:d,signal:e}):yield this._uvFromServiceQuery({sqlExpression:h.expression,valueExpression:b,signal:e});return p.getPredominantCategoriesFromUVInfos(b.uniqueValueInfos,
c)});return function(b){return a.apply(this,arguments)}}();m.getSampleFeatures=function(){var a=x._asyncToGenerator(function*(b,c){const {view:d,sampleSize:e,requiredFields:h,returnGeometry:k,signal:f}=b,g=this.layer.createQuery(),l="json"===c;g.outSpatialReference=b.spatialReference||d&&d.spatialReference;g.returnGeometry=!!k;g.outFields=h;let n=[],t=!1;if(d)try{const q=yield d.whenLayerView(this.layer);if(t=!(yield p.getMissingFields(this,h,q)).length)if(n=yield this._fetchFeaturesFromMemory(q,
g,f,c),n.length&&0<e&&e<=n.length)return J.pickRandom(n,e,1)}catch(q){A.throwIfAborted(f)}try{if(this._hasLocalSource)return t?n:l?this._fetchFeaturesJSONFromService(g,f):this._fetchFeaturesFromService(g,f);const q=yield this.queryFeatureCount({view:d,signal:f}),r=this.layer.capabilities.query.maxRecordCount;c=-1===e?q:e;c=r&&c>r?r:c;if(q<=n.length||n.length>=r)return n;const w=d.extent.width/d.width/d.scale*4E5;g.maxAllowableOffset=b.resolution||w;if(q<=c)return l?this._fetchFeaturesJSONFromService(g,
f):this._fetchFeaturesFromService(g,f);if(2E4>=q){const z=yield this.layer.queryObjectIds();g.objectIds=J.pickRandom(z,c,1);return l?this._fetchFeaturesJSONFromService(g,f):this._fetchFeaturesFromService(g,f)}this.layer.get("capabilities.query.supportsPagination")&&(g.num=Math.min(c,2E4));return l?this._fetchFeaturesJSONFromService(g,f):this._fetchFeaturesFromService(g,f)}catch(q){return A.throwIfAborted(f),n}});return function(b,c){return a.apply(this,arguments)}}();m.load=function(a){var b=this;
const c=this.layer.load(a).then(function(){var d=x._asyncToGenerator(function*(e){b.geometryType=e.geometryType;b.objectIdField=e.objectIdField;b.supportsSQLExpression=e.get("capabilities.query.supportsSqlExpression");b._hasLocalSource=!e.url&&!!e.source;b.hasQueryEngine=b._hasLocalSource;b.minScale=e.minScale;b.maxScale=e.maxScale;b.fullExtent=e.fullExtent;b.workerClient=W.WorkerClient.getInstance();yield b.workerClient.open(E.unwrap(E.unwrap(a).signal))});return function(e){return d.apply(this,
arguments)}}());this.addResolvingPromise(c);return Promise.resolve(this)};return H}(X);I.__decorate([R.property({constructOnly:!0})],C.prototype,"layer",void 0);return C=I.__decorate([S.subclass("esri.smartMapping.support.adapters.FeatureLayerAdapter")],C)});
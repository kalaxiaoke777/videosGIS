// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.21/esri/copyright.txt for details.
//>>built
define("../../../../chunks/_rollupPluginBabelHelpers ../../../../core/maybe ../../../../geometry/support/aaBoundingRect ../../../../geometry/support/centroid ../../../../geometry/support/jsonUtils ../../../../geometry/support/normalizeUtilsCommon ../../../../geometry/support/quantizationUtils ../../../../layers/graphics/featureConversionUtils ../../../../layers/graphics/OptimizedGeometry ./graphicsUtils".split(" "),function(z,A,p,B,q,C,r,t,k,v){function x(e){e.coords.length=0;e.lengths.length=0}const m=
new k,w=new k;k=function(){function e(){this.bounds=p.create();this.graphic=null;this.size=[0,0,0,0]}e.acquire=function(a=null,d,b,c,f,h){let g;0===e._pool.length?g=new e:(g=e._pool.pop(),this._set.delete(g));g.acquire(a,d,b,c,f,h);return g};e.release=function(a){a&&!this._set.has(a)&&(a.release(),this._pool.push(a),this._set.add(a))};e.getCentroidQuantized=function(a,d){if(q.isPolygon(a.geometry)){const b=a.symbol;if(A.isNone(b))return null;if(v.isMarkerSymbol(b.type)||v.isTextSymbol(b.type))return a=
B.polygonCentroid(a.geometry),r.quantizePoint(d,{},{x:a[0],y:a[1]},!1,!1)}return null};var n=e.prototype;n.acquire=function(a=null,d,b,c,f,h){a&&this.set(a,d,b,c,f,h)};n.release=function(){this.geometry=this.symbolResource=this.graphic=null};n.set=function(a,d,b,c,f,h){this.graphic=a;this.geometry=b;this.symbolResource=d;this.resolution=c;this.updateBounds(c,f,h)};n.updateBounds=function(a,d,b){v.getBounds(this.bounds,this.size,this.symbolResource,this.geometry,a,d,b)};n.getGeometryQuantized=function(a,
d,b){const c=this.geometry;if(q.isPolygon(c)){if(b=c.rings,1===b.length&&2===b[0].length)return r.quantizeGeometry(a,{paths:[[b[0][0],b[0][1]]]})}else{if(q.isPolyline(c))return x(m),x(w),t.convertFromPolyline(m,c),t.generalizeOptimizedGeometry(w,m,c.hasZ,c.hasM,"esriGeometryPolyline",a.scale[0]),t.quantizeOptimizedGeometry(m,w,c.hasZ,c.hasM,"esriGeometryPolyline",a),t.convertToPolyline(m,c.hasZ,c.hasM);if(q.isMultipoint(c)){const f=this.resolution*this.size[0],[h,g]=C.getSpatialReferenceMinMaxX(b),
y=g-h;b=c.points.filter(l=>{if(l[0]+f>g||l[0]-f<h){const u=[...l];u[0]=l[0]+f>g?u[0]-y:u[0]+y;return p.containsPointWithMargin(d,l,f)||p.containsPointWithMargin(d,u,f)}return p.containsPointWithMargin(d,l,f)});return 0===b.length?{points:b}:r.quantizeGeometry(a,{points:b})}}return r.quantizeGeometry(a,this.geometry)};z._createClass(e,[{key:"symbol",get:function(){return this.symbolResource.symbol}}]);return e}();k._pool=[];k._set=new Set;return k});
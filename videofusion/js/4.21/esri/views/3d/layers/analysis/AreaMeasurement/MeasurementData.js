// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.21/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/mathUtils ../../../../../core/maybe ../../../../../core/Quantity ../../../../../chunks/earcut ../../../../../chunks/vec2 ../../../../../chunks/vec2f64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../chunks/vec4f64 ../../../../../geometry/projection ../../../../../geometry/projectionEllipsoid ../../../../../geometry/SpatialReference ../../../../../geometry/support/intersectsBase ../support/measurementUtils ../support/viewUtils ../../../support/ElevationProvider ../../../support/mathUtils".split(" "),
function(E,K,L,A,F,B,G,l,g,M,u,C,N,H,w,I,O,D){function J(z,m){const a=new Float64Array(z.length*m);for(let c=0;c<z.length;++c){const d=z[c];for(let b=0;b<m;++b)a[c*m+b]=d[b]}return a}let P=function(){function z(a,c){this.positionsWorldCoords=[];this.positionsRenderCoords=[];this.positionsProjectedWorldCoords=[];this.positionsFittedRenderCoords=[];this.positionsGeographic=[];this.positionsSpherical=[];this.positionsStereographic=[];this.pathSegmentLengths=[];this.geodesicPathSegmentLengths=[];this.perimeterSegmentLengths=
[];this.intersectingSegments=new Set;this.geodesicIntersectingSegments=new Set;this.areaCentroidWorldCoords=g.create();this.areaCentroidRenderCoords=g.create();this.geodesicAreaCentroidRenderCoords=g.create();this._length=0;this._centroidRenderCoords=g.create();this._planeWorldCoords=M.create();this._worldUp=g.create();this._worldTangent=g.create();this._frame=[g.create(),g.create(),g.create()];this._pathVersion=-1;this._validMeasurement=!1;this._tempU=g.create();this._tempV=g.create();this._tempVec3=
g.create();this._tempSphere={center:g.create(),radius:0};this._sceneView=a;this.unitNormalizer=c}var m=z.prototype;m.update=function(a,c,d,b,e){const f=this.unitNormalizer,n=this._sceneView.renderSpatialReference,v=this.unitNormalizer.spatialReference;if(this._pathVersion===a.version&&this._validMeasurement===d&&!e)return!1;this._pathVersion=a.version;this._validMeasurement=d;this._resize(a.numVertices);const q=C.getSphericalPCPF(c.spatialReference),h=u.canProjectWithoutEngine(c.spatialReference,
q)&&u.canProjectToWGS84ComparableLonLat(c.spatialReference),k=this.positionsGeographic,x=this.positionsWorldCoords,y=this.positionsRenderCoords,r=this.positionsSpherical;a.forEachVertexPosition((p,t)=>{p.hasZ||(p.z=L.unwrapOr(O.getElevationAtPoint(c.elevationProvider,p,"ground"),0));u.projectPointToVector(p,x[t],v);u.projectPointToVector(p,y[t],n);h&&(u.projectPointToWGS84ComparableLonLat(p,k[t]),u.projectPointToVector(p,r[t],q),l.normalize(r[t],r[t]))});a=this._updatePathLengths(d);this.pathLength=
1<this._length?new A(f.normalizeDistance(a),"meters"):null;h?(a=this._updateGeodesicPathLengths(d,v),this.geodesicPathLength=1<this._length?new A(a,"meters"):null):this.geodesicPathLength=null;if(!d)return this.geodesicTriangleIndices=this.triangleIndices=this.perimeterLength=this.geodesicArea=this.area=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0;this._updateArea(c,f,n,v,b);h&&this._updateGeodesicArea(c);return!0};m.getData=function(){return{positionsWorldCoords:this.positionsWorldCoords,
positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,
geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,
unitNormalizer:this.unitNormalizer}};m._resize=function(a){a<this._length&&(this.positionsWorldCoords.length=a,this.positionsRenderCoords.length=a,this.positionsProjectedWorldCoords.length=a,this.positionsFittedRenderCoords.length=a,this.positionsGeographic.length=a,this.positionsSpherical.length=a,this.positionsStereographic.length=a,this.pathSegmentLengths.length=a,this.geodesicPathSegmentLengths.length=a,this._length=this.perimeterSegmentLengths.length=a);for(;this._length<a;)this.positionsWorldCoords.push(g.create()),
this.positionsRenderCoords.push(g.create()),this.positionsProjectedWorldCoords.push(G.create()),this.positionsFittedRenderCoords.push(g.create()),this.positionsGeographic.push(g.create()),this.positionsSpherical.push(g.create()),this.positionsStereographic.push(G.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length};m._updatePathLengths=function(a){const c=this.positionsWorldCoords,d=this.pathSegmentLengths;let b=0;for(let e=
0;e<this._length;++e){const f=d[e]=l.distance(c[e],c[(e+1)%this._length]);if(e<this._length-1||a)b+=f}return b};m._updateGeodesicPathLengths=function(a,c){const d=this.positionsGeographic,b=this.geodesicPathSegmentLengths;let e=0;for(let f=0;f<this._length;++f){const n=b[f]=w.segmentLengthGeodesicVector(d[f],d[(f+1)%this._length],c);if(f<this._length-1||a)e+=n}return e};m._updateArea=function(a,c,d,b,e){const f=a.renderCoordsHelper;a=this.positionsWorldCoords;const n=this.positionsRenderCoords,v=
this.positionsProjectedWorldCoords,q=this.positionsFittedRenderCoords;var h=this._planeWorldCoords,k=this._centroidRenderCoords;I.midpoint(n,k);f.worldUpAtPosition(k,this._worldUp);f.worldBasisAtPosition(k,0,this._worldTangent);u.projectDirection(k,this._worldUp,d,this._worldUp,b);u.projectDirection(k,this._worldTangent,d,this._worldTangent,b);2<a.length&&w.bestFitPlane(a,h);this.fittingMode=this._selectFittingMode(h,a,this._worldUp,e);let x=0;if("horizontal"===this.fittingMode){let r=-Infinity;n.forEach((p,
t)=>{p=f.getAltitude(n[t]);p>r&&(r=p,x=t)})}e=a[x];k=h;var y=this._worldTangent;"horizontal"===this.fittingMode?k=this._worldUp:"vertical"===this.fittingMode&&(k=this._tempVec3,y=this._worldUp,D.makeOrthonormal(h,this._worldUp,k));l.copy(this._frame[2],k);D.makeOrthonormal(y,k,this._frame[0]);l.cross(this._frame[1],this._frame[0],this._frame[2]);l.negate(this._frame[1],this._frame[1]);h=this._tempVec3;k=this._tempU;y=this._tempV;for(let r=0;r<this._length;++r){const p=v[r],t=q[r];l.subtract(h,a[r],
e);B.set(p,l.dot(this._frame[0],h),l.dot(this._frame[1],h));l.scale(k,this._frame[0],p[0]);l.scale(y,this._frame[1],p[1]);l.add(h,k,y);l.add(h,h,e);u.projectVectorToVector(h,b,t,d)}this.perimeterLength=0<this._length?new A(c.normalizeDistance(this._updatePerimeterLengths()),"meters"):null;I.midpoint(q,this.areaCentroidRenderCoords);u.projectVectorToVector(this.areaCentroidRenderCoords,d,this.areaCentroidWorldCoords,b);this._updateIntersectingSegments();this.area=0===this.intersectingSegments.size?
new A(c.normalizeArea(this._computeArea()),"square-meters"):null};m._updateGeodesicArea=function(a){const c=a.renderCoordsHelper,d=this.positionsSpherical,b=this.positionsStereographic,e=this._tempVec3,f=w.fitHemisphere(d,e);if(f){var n=this._tempU,v=this._tempV;D.tangentFrame(e,n,v);for(let q=0;q<this._length;++q){const h=l.dot(d[q],n),k=l.dot(d[q],v),x=l.dot(d[q],e);B.set(b[q],h/x,k/x)}l.scale(e,e,C.getReferenceEllipsoid(a.spatialReference).radius);c.toRenderCoords(e,C.getSphericalPCPF(a.spatialReference),
this.geodesicAreaCentroidRenderCoords);this._updateGeodesicIntersectingSegments();this.geodesicArea=f&&0===this.geodesicIntersectingSegments.size?new A(this._computeGeodesicArea(),"square-meters"):null}else this.geodesicArea=null};m._updatePerimeterLengths=function(){const a=this.positionsProjectedWorldCoords,c=this.perimeterSegmentLengths;let d=0;for(let b=0;b<this._length;++b){const e=c[b]=B.distance(a[b],a[(b+1)%this._length]);d+=e}return d};m._updateIntersectingSegments=function(){const a=this.positionsProjectedWorldCoords,
c=this.intersectingSegments;c.clear();for(let d=0;d<this._length;++d)for(let b=d+2;b<this._length;++b)(b+1)%this._length!==d&&H.segmentIntersects(a[d],a[(d+1)%this._length],a[b],a[(b+1)%this._length])&&(c.add(d),c.add(b))};m._computeArea=function(){const a=this.positionsProjectedWorldCoords;var c=J(a,2);c=this.triangleIndices=new Uint32Array(F.earcut(c,[],2));let d=0;for(let b=0;b<c.length;b+=3)d+=w.triangleAreaEuclidean(a[c[b]],a[c[b+1]],a[c[b+2]]);return d};m._updateGeodesicIntersectingSegments=
function(){const a=this.positionsStereographic,c=this.geodesicIntersectingSegments;c.clear();for(let d=0;d<this._length;++d)for(let b=d+2;b<this._length;++b)(b+1)%this._length!==d&&H.segmentIntersects(a[d],a[(d+1)%this._length],a[b],a[(b+1)%this._length])&&(c.add(d),c.add(b))};m._computeGeodesicArea=function(){const a=this.positionsGeographic;var c=J(this.positionsStereographic,2);c=this.geodesicTriangleIndices=new Uint32Array(F.earcut(c,[],2));let d=0;for(let b=0;b<c.length;b+=3)d+=w.triangleAreaGeodesic(a[c[b]],
a[c[b+1]],a[c[b+2]],N.WGS84);return d};m._selectFittingMode=function(a,c,d,b){var e=c.map(n=>Math.abs(w.planePointDistance(a,n))).reduce((n,v)=>Math.max(n,v),0);w.boundingSphere(c,this._tempSphere);c=e/(2*this._tempSphere.radius);e=c<b.maxRelativeErrorAlmostCoplanar;let f="horizontal";c<b.maxRelativeErrorCoplanar?f="oblique":e&&(f=Math.abs(l.dot(d,a))>Math.cos(K.deg2rad(b.verticalAngleThreshold))?"horizontal":"vertical");return f};return z}();E.MeasurementDataManager=P;Object.defineProperty(E,"__esModule",
{value:!0})});
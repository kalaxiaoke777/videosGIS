<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>è§†é¢‘èåˆåœ°å›¾ - Video Fusion Map</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js"></script>
    <link
      href="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css"
      rel="stylesheet"
    />
    <style>
      * {
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      #cesiumContainer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* é¡¶éƒ¨æ ‡é¢˜æ  */
      #titleBar {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        z-index: 2000;
        display: flex;
        align-items: center;
        padding: 0 20px;
      }

      #titleBar h1 {
        margin: 0;
        color: white;
        font-size: 20px;
        font-weight: 600;
        flex: 1;
      }

      #titleBar .status {
        color: rgba(255, 255, 255, 0.9);
        font-size: 13px;
        padding: 6px 12px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 20px;
      }

      /* å·¦ä¾§æ§åˆ¶é¢æ¿ */
      #controlPanel {
        position: absolute;
        top: 80px;
        left: 20px;
        width: 300px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        z-index: 1100;
        overflow: hidden;
      }

      .panel-section {
        padding: 20px;
        border-bottom: 1px solid #e0e0e0;
      }

      .panel-section:last-child {
        border-bottom: none;
      }

      .panel-section h3 {
        margin: 0 0 15px 0;
        font-size: 14px;
        font-weight: 600;
        color: #333;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .button-group {
        display: flex;
        gap: 8px;
        margin-bottom: 10px;
      }

      button {
        flex: 1;
        padding: 10px 16px;
        border: none;
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        outline: none;
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      button:active {
        transform: translateY(0);
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .btn-primary:hover {
        background: linear-gradient(135deg, #5568d3 0%, #66398d 100%);
      }

      .btn-success {
        background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
        color: white;
      }

      .btn-success:hover {
        background: linear-gradient(135deg, #4a9528 0%, #94c956 100%);
      }

      .btn-danger {
        background: linear-gradient(135deg, #f85032 0%, #e73827 100%);
        color: white;
      }

      .btn-danger:hover {
        background: linear-gradient(135deg, #e0442b 0%, #d42e1f 100%);
      }

      button:disabled {
        background: #ccc !important;
        cursor: not-allowed;
        transform: none !important;
        box-shadow: none !important;
      }

      .hint-text {
        display: block;
        margin-top: 10px;
        padding: 10px;
        background: #f0f4ff;
        border-left: 3px solid #667eea;
        border-radius: 4px;
        font-size: 12px;
        color: #555;
        line-height: 1.5;
      }

      .info-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        font-size: 13px;
        color: #666;
      }

      .info-item strong {
        color: #333;
      }
      .info-value {
        color: #667eea;
        font-weight: 600;
      }

      /* ç‚¹ä½åˆ—è¡¨æ ·å¼ */
      .point-item {
        padding: 10px;
        margin-bottom: 8px;
        background: #f8f9fa;
        border-radius: 6px;
        border-left: 3px solid #667eea;
        font-size: 12px;
      }

      .point-item-header {
        font-weight: 600;
        color: #333;
        margin-bottom: 4px;
      }

      .point-coords {
        color: #666;
        font-family: "Courier New", monospace;
        line-height: 1.4;
      } /* å³ä¾§è§†é¢‘é¢„è§ˆ - éšè— */
      #videoContainer {
        display: none;
      }
      #videoContainer h3 {
        display: none;
      }

      #videoSource {
        display: none;
      }

      #videoInfo {
        display: none;
      }

      .video-controls {
        display: none;
      }

      .video-controls button {
        display: none;
      }

      /* åŠ è½½åŠ¨ç”» */
      .loading {
        display: inline-block;
        width: 12px;
        height: 12px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-top-color: white;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        margin-left: 8px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      } /* å“åº”å¼è°ƒæ•´ */
      @media (max-width: 1200px) {
        #controlPanel {
          width: 280px;
        }
      }
    </style>
  </head>
  <body>
    <div id="cesiumContainer"></div>

    <!-- é¡¶éƒ¨æ ‡é¢˜æ  -->
    <div id="titleBar">
      <h1>ğŸ¥ è§†é¢‘èåˆåœ°å›¾ç³»ç»Ÿ</h1>
      <span class="status" id="statusText">å°±ç»ª</span>
    </div>

    <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
    <div id="controlPanel">
      <div class="panel-section">
        <h3>ğŸ“ åŒºåŸŸç»˜åˆ¶</h3>
        <div class="button-group">
          <button id="btnStartDraw" class="btn-primary">å¼€å§‹ç»˜åˆ¶</button>
          <button id="btnFinishDraw" class="btn-success" disabled>
            å®Œæˆç»˜åˆ¶
          </button>
        </div>
        <button
          id="btnAddPoint"
          class="btn-primary"
          style="width: 100%; margin-bottom: 10px"
          disabled
        >
          â• æ·»åŠ ç‚¹ä½
        </button>
        <button id="btnClearDraw" class="btn-danger" style="width: 100%">
          æ¸…é™¤åŒºåŸŸ
        </button>
        <span class="hint-text" id="drawHint"
          >ç‚¹å‡»"å¼€å§‹ç»˜åˆ¶"åï¼Œåœ¨åœ°å›¾ä¸Šä¾æ¬¡ç‚¹å‡»æ·»åŠ å¤šè¾¹å½¢é¡¶ç‚¹</span
        >
      </div>
      <div class="panel-section">
        <h3>ğŸ“Š çŠ¶æ€ä¿¡æ¯</h3>
        <div class="info-item">
          <strong>ç»˜åˆ¶ç‚¹æ•°:</strong>
          <span class="info-value" id="pointCount">0</span>
        </div>
        <div class="info-item">
          <strong>è§†é¢‘çŠ¶æ€:</strong>
          <span class="info-value" id="videoStatus">æœªåŠ è½½</span>
        </div>
        <div class="info-item">
          <strong>è´´å›¾çŠ¶æ€:</strong>
          <span class="info-value" id="mappingStatus">æœªæ˜ å°„</span>
        </div>
      </div>

      <div class="panel-section" id="pointListSection" style="display: none">
        <h3>ğŸ“Œ ç‚¹ä½åæ ‡</h3>
        <div id="pointList" style="max-height: 300px; overflow-y: auto">
          <!-- ç‚¹ä½åˆ—è¡¨å°†åŠ¨æ€æ’å…¥è¿™é‡Œ -->
        </div>
      </div>

      <!-- å¯¼å…¥/å¯¼å‡º -->
      <div class="panel-section">
        <h3>â¬‡ï¸/â¬†ï¸ å¯¼å…¥å¯¼å‡º</h3>
        <div class="button-group">
          <button id="btnExport" class="btn-primary">å¯¼å‡ºç‚¹ä½ (JSON)</button>
          <button id="btnImport" class="btn-primary">å¯¼å…¥ç‚¹ä½ (JSON)</button>
        </div>
        <input
          type="file"
          id="importFileInput"
          accept=".json"
          style="display: none"
        />
        <div class="hint-text">
          å¯¼å‡ºå°†ä¸‹è½½ä¸€ä¸ª JSON æ–‡ä»¶ï¼›å¯¼å…¥è¯·é€‰æ‹©ç¬¦åˆæ ¼å¼çš„ JSON æ–‡ä»¶ï¼Œæ ¼å¼ç¤ºä¾‹:
          {"points":[{"lon":121.42,"lat":29.67,"height":10},...]}
        </div>
      </div>
    </div>

    <!-- å³ä¾§è§†é¢‘é¢„è§ˆ -->
    <div id="videoContainer">
      <h3>ğŸ¬ è§†é¢‘é¢„è§ˆ</h3>
      <video id="videoSource" muted loop playsinline controls>
        <source src="data/data_clipped_30s.mp4" type="video/mp4" />
      </video>
      <div id="videoInfo">
        <div class="info-item">
          <strong>åˆ†è¾¨ç‡:</strong>
          <span id="videoRes">-</span>
        </div>
        <div class="video-controls">
          <button id="btnPlayPause" class="btn-primary">æ’­æ”¾/æš‚åœ</button>
          <button id="btnRestart" class="btn-primary">é‡æ–°å¼€å§‹</button>
        </div>
      </div>
    </div>
    <script>
      // è®¾ç½® Cesium Ion Token
      Cesium.Ion.defaultAccessToken =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJkOGFjOTU5Zi0xOTU1LTRlOTctOTg4Ny05MGJmYmNhMDdhNTgiLCJpZCI6MTUxNTAxLCJpYXQiOjE3MDUzOTQ0OTl9.8SXHmK_7zqWsYcIY5GLJbeez-4JTQo9ePfpKV8Q5Stg"; // åˆå§‹åŒ– Cesium Viewer
      const viewer = new Cesium.Viewer("cesiumContainer", {
        baseLayerPicker: false,
        geocoder: false,
        homeButton: false,
        sceneModePicker: false,
        navigationHelpButton: false,
        timeline: false,
        animation: false,
        fullscreenButton: false,
        vrButton: false,
        shouldAnimate: true,
        terrain: Cesium.Terrain.fromWorldTerrain(),
      });

      // éšè—ç‰ˆæƒä¿¡æ¯
      viewer.cesiumWidget.creditContainer.style.display = "none";

      console.log("Cesium Viewer åˆå§‹åŒ–æˆåŠŸ");

      // UI å…ƒç´ 
      const video = document.getElementById("videoSource");
      const videoResSpan = document.getElementById("videoRes");
      const statusText = document.getElementById("statusText");
      const drawHint = document.getElementById("drawHint");
      const pointCount = document.getElementById("pointCount");
      const videoStatus = document.getElementById("videoStatus");
      const mappingStatus = document.getElementById("mappingStatus"); // ç»˜åˆ¶ç›¸å…³å˜é‡
      let drawing = false;
      let drawPositions = [];
      let drawEntity = null;
      let videoPolygonEntity = null;
      let editMode = false; // æ˜¯å¦å¤„äºç¼–è¾‘æ¨¡å¼
      let addingPoint = false; // æ˜¯å¦å¤„äºæ·»åŠ ç‚¹æ¨¡å¼
      let pointEntities = []; // å­˜å‚¨æ‰€æœ‰ç‚¹å®ä½“
      let draggedPointIndex = -1; // å½“å‰æ‹–åŠ¨çš„ç‚¹ç´¢å¼•
      let previewLine = null; // é¢„è§ˆçº¿
      const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

      // æŒ‰é’®ç»‘å®š
      const btnStartDraw = document.getElementById("btnStartDraw");
      const btnFinishDraw = document.getElementById("btnFinishDraw");
      const btnAddPoint = document.getElementById("btnAddPoint");
      const btnClearDraw = document.getElementById("btnClearDraw");
      const btnPlayPause = document.getElementById("btnPlayPause");
      const btnRestart = document.getElementById("btnRestart");
      const btnExport = document.getElementById("btnExport");
      const btnImport = document.getElementById("btnImport");
      const importFileInput = document.getElementById("importFileInput");

      // æ›´æ–°çŠ¶æ€å‡½æ•°
      function updateStatus(text, isSuccess = true) {
        statusText.textContent = text;
        statusText.style.background = isSuccess
          ? "rgba(76, 175, 80, 0.3)"
          : "rgba(244, 67, 54, 0.3)";
      }

      // å¼€å§‹ç»˜åˆ¶
      btnStartDraw.onclick = () => {
        drawing = true;
        drawPositions = [];
        if (drawEntity) {
          viewer.entities.remove(drawEntity);
          drawEntity = null;
        }
        if (videoPolygonEntity) {
          viewer.entities.remove(videoPolygonEntity);
          videoPolygonEntity = null;
        }
        btnStartDraw.disabled = true;
        btnFinishDraw.disabled = false;
        drawHint.textContent = "åœ¨åœ°å›¾ä¸Šç‚¹å‡»æ·»åŠ é¡¶ç‚¹ï¼Œè‡³å°‘éœ€è¦ 3 ä¸ªç‚¹";
        pointCount.textContent = "0";
        mappingStatus.textContent = "æœªæ˜ å°„";
        updateStatus("ç»˜åˆ¶ä¸­...");
      }; // å®Œæˆç»˜åˆ¶
      btnFinishDraw.onclick = () => {
        drawing = false;
        btnStartDraw.disabled = false;
        btnFinishDraw.disabled = true;

        if (drawPositions.length < 3) {
          drawHint.textContent = "ç‚¹æ•°ä¸è¶³ 3 ä¸ªï¼Œæ— æ³•æ„æˆå¤šè¾¹å½¢";
          updateStatus("ç»˜åˆ¶å¤±è´¥", false);
          return;
        }
        drawHint.textContent = "ç»˜åˆ¶å®Œæˆï¼å¯ä»¥æ‹–åŠ¨ç‚¹ä½è°ƒæ•´å½¢çŠ¶æˆ–æ·»åŠ æ–°ç‚¹";
        createVideoPolygon(drawPositions);
        updateStatus("è§†é¢‘æ˜ å°„æˆåŠŸ - å¯ç¼–è¾‘æ¨¡å¼");
        mappingStatus.textContent = "å·²æ˜ å°„";

        // è¿›å…¥ç¼–è¾‘æ¨¡å¼
        editMode = true;
        btnAddPoint.disabled = false;
        createEditablePoints();
        updatePointList();
      };

      // æ·»åŠ ç‚¹ä½æŒ‰é’®
      btnAddPoint.onclick = () => {
        if (!editMode) return;

        addingPoint = !addingPoint;

        if (addingPoint) {
          btnAddPoint.textContent = "âœ“ å®Œæˆæ·»åŠ ";
          btnAddPoint.classList.remove("btn-primary");
          btnAddPoint.classList.add("btn-success");
          drawHint.textContent = "ç‚¹å‡»å¤šè¾¹å½¢è¾¹ç¼˜æ·»åŠ æ–°ç‚¹ä½";
          updateStatus("æ·»åŠ ç‚¹æ¨¡å¼");
        } else {
          btnAddPoint.textContent = "â• æ·»åŠ ç‚¹ä½";
          btnAddPoint.classList.remove("btn-success");
          btnAddPoint.classList.add("btn-primary");
          drawHint.textContent = "ç»˜åˆ¶å®Œæˆï¼å¯ä»¥æ‹–åŠ¨ç‚¹ä½è°ƒæ•´å½¢çŠ¶æˆ–æ·»åŠ æ–°ç‚¹";
          updateStatus("ç¼–è¾‘æ¨¡å¼");

          // ç§»é™¤é¢„è§ˆçº¿
          if (previewLine) {
            viewer.entities.remove(previewLine);
            previewLine = null;
          }
        }
      }; // æ¸…é™¤åŒºåŸŸ
      btnClearDraw.onclick = () => {
        drawing = false;
        editMode = false;
        addingPoint = false;
        drawPositions = [];
        pointEntities = [];
        draggedPointIndex = -1;
        btnStartDraw.disabled = false;
        btnFinishDraw.disabled = true;
        btnAddPoint.disabled = true;

        // ç§»é™¤ç»˜åˆ¶å®ä½“
        if (drawEntity) {
          viewer.entities.remove(drawEntity);
          drawEntity = null;
        }

        // ç§»é™¤è§†é¢‘å¤šè¾¹å½¢
        if (videoPolygonEntity) {
          viewer.entities.remove(videoPolygonEntity);
          videoPolygonEntity = null;
        }

        // ç§»é™¤é¢„è§ˆçº¿
        if (previewLine) {
          viewer.entities.remove(previewLine);
          previewLine = null;
        }

        // ç§»é™¤æ‰€æœ‰ç‚¹æ ‡è®°
        const entitiesToRemove = [];
        viewer.entities.values.forEach((entity) => {
          if (entity.point) {
            entitiesToRemove.push(entity);
          }
        });
        entitiesToRemove.forEach((entity) => {
          viewer.entities.remove(entity);
        });

        drawHint.textContent =
          'ç‚¹å‡»"å¼€å§‹ç»˜åˆ¶"å,åœ¨åœ°å›¾ä¸Šä¾æ¬¡ç‚¹å‡»æ·»åŠ å¤šè¾¹å½¢é¡¶ç‚¹';
        pointCount.textContent = "0";
        mappingStatus.textContent = "æœªæ˜ å°„";

        // éšè—ç‚¹ä½åˆ—è¡¨
        document.getElementById("pointListSection").style.display = "none";

        updateStatus("å°±ç»ª");
      };

      // æ’­æ”¾/æš‚åœ
      btnPlayPause.onclick = () => {
        if (video.paused) {
          video.play();
        } else {
          video.pause();
        }
      };

      // é‡æ–°å¼€å§‹
      btnRestart.onclick = () => {
        video.currentTime = 0;
        video.play();
      };

      // å¯¼å‡ºç‚¹ä½ä¸º JSON å¹¶è§¦å‘ä¸‹è½½
      function exportPoints() {
        if (!drawPositions || drawPositions.length === 0) {
          alert("æ²¡æœ‰å¯å¯¼å‡ºçš„ç‚¹ä½");
          return;
        }
        const pts = drawPositions.map((pos) => {
          const carto = Cesium.Cartographic.fromCartesian(pos);
          return {
            lon: Number(Cesium.Math.toDegrees(carto.longitude).toFixed(6)),
            lat: Number(Cesium.Math.toDegrees(carto.latitude).toFixed(6)),
            height: Number(carto.height.toFixed(2)),
          };
        });
        const payload = { points: pts };
        const json = JSON.stringify(payload, null, 2);

        // è§¦å‘ä¸‹è½½
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "points.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);

        // ä¹Ÿå¼¹å‡ºé¢„è§ˆï¼ˆå¦‚æœ JSON ä¸å¤§ï¼‰
        alert("å¯¼å‡ºæˆåŠŸï¼Œå·²è§¦å‘ä¸‹è½½ã€‚JSON é¢„è§ˆ:\n" + json.slice(0, 1000));
      }

      // ä»è§£æåçš„å¯¹è±¡å¯¼å…¥ç‚¹ä½ (æ ¼å¼: {points:[{lon,lat,height},...]})
      function importPointsFromObject(obj) {
        if (!obj || !Array.isArray(obj.points)) {
          alert("å¯¼å…¥ JSON æ ¼å¼é”™è¯¯ï¼Œéœ€åŒ…å« points æ•°ç»„");
          return;
        }
        // è½¬æ¢ä¸º Cartesian3
        drawPositions = obj.points.map((p) =>
          Cesium.Cartesian3.fromDegrees(p.lon, p.lat, p.height || 0)
        );

        // åˆ›å»º/æ›´æ–°è§†é¢‘å¤šè¾¹å½¢ä¸ç‚¹ä½
        createVideoPolygon(drawPositions);
        createEditablePoints();
        updatePointList();
        editMode = true;
        btnAddPoint.disabled = false;
        mappingStatus.textContent = "å·²æ˜ å°„";
        updateStatus("å·²å¯¼å…¥ç‚¹ä½å¹¶æ˜ å°„");
      }

      // å¤„ç†æ–‡ä»¶è¾“å…¥
      importFileInput.addEventListener("change", (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const obj = JSON.parse(reader.result);
            importPointsFromObject(obj);
          } catch (err) {
            alert("è§£æ JSON å¤±è´¥: " + err);
          }
        };
        reader.readAsText(file);
        // æ¸…ç©ºä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥é€‰åŒä¸€ä¸ªæ–‡ä»¶
        importFileInput.value = null;
      });

      // å¯¼å…¥/å¯¼å‡ºæŒ‰é’®ç»‘å®š
      btnExport.onclick = exportPoints;
      btnImport.onclick = () => importFileInput.click();

      // åœ°å›¾ç‚¹å‡»äº‹ä»¶ - é‡‡é›†ç‚¹
      handler.setInputAction((movement) => {
        if (!drawing && !addingPoint) return;

        const ray = viewer.camera.getPickRay(movement.position);
        const position = viewer.scene.globe.pick(ray, viewer.scene);

        if (!position) {
          console.warn("æ— æ³•è·å–ç‚¹å‡»ä½ç½®");
          return;
        }

        // å¦‚æœæ˜¯ç»˜åˆ¶æ¨¡å¼
        if (drawing) {
          drawPositions.push(position);
          pointCount.textContent = drawPositions.length;

          // æ·»åŠ ç‚¹æ ‡è®°
          viewer.entities.add({
            position: position,
            point: {
              pixelSize: 8,
              color: Cesium.Color.YELLOW,
              outlineColor: Cesium.Color.WHITE,
              outlineWidth: 2,
            },
          });

          if (!drawEntity) {
            drawEntity = viewer.entities.add({
              polygon: {
                hierarchy: new Cesium.CallbackProperty(() => {
                  return new Cesium.PolygonHierarchy(drawPositions);
                }, false),
                material: Cesium.Color.YELLOW.withAlpha(0.3),
                outline: true,
                outlineColor: Cesium.Color.YELLOW,
                outlineWidth: 3,
                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
              },
            });
          }
        }

        // å¦‚æœæ˜¯æ·»åŠ ç‚¹æ¨¡å¼
        if (addingPoint) {
          // æ‰¾åˆ°æœ€è¿‘çš„è¾¹
          const result = findClosestEdge(position);
          if (result) {
            // åœ¨è¯¥è¾¹ä¸Šæ’å…¥æ–°ç‚¹
            drawPositions.splice(result.insertIndex, 0, result.closestPoint);
            pointCount.textContent = drawPositions.length;

            // æ›´æ–°æ‰€æœ‰å†…å®¹
            createEditablePoints();
            updatePointList();

            // æ›´æ–°è§†é¢‘å¤šè¾¹å½¢
            if (videoPolygonEntity) {
              videoPolygonEntity.polygon.hierarchy =
                new Cesium.PolygonHierarchy(drawPositions);
            }

            updateStatus(`å·²æ·»åŠ ç‚¹ä½ P${result.insertIndex + 1}`);
          }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK); // åˆ›å»ºè§†é¢‘å¤šè¾¹å½¢
      function createVideoPolygon(positionsCartesian) {
        if (videoPolygonEntity) {
          viewer.entities.remove(videoPolygonEntity);
        }

        // ç§»é™¤æ‰€æœ‰ç»˜åˆ¶æ—¶çš„ç‚¹æ ‡è®°
        const entitiesToRemove = [];
        viewer.entities.values.forEach((entity) => {
          if (entity.point) {
            entitiesToRemove.push(entity);
          }
        });
        entitiesToRemove.forEach((entity) => {
          viewer.entities.remove(entity);
        });

        // åˆ›å»ºè§†é¢‘æè´¨
        const material = new Cesium.ImageMaterialProperty({
          image: video,
          transparent: false,
        });

        // åˆ›å»ºè§†é¢‘å¤šè¾¹å½¢å®ä½“
        videoPolygonEntity = viewer.entities.add({
          name: "VideoPolygon",
          polygon: {
            hierarchy: new Cesium.PolygonHierarchy(positionsCartesian),
            material: material,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
          },
        });

        // ç§»é™¤é»„è‰²ç»˜åˆ¶å¤šè¾¹å½¢
        if (drawEntity) {
          viewer.entities.remove(drawEntity);
          drawEntity = null;
        }

        // é£å‘è§†é¢‘å¤šè¾¹å½¢
        viewer.flyTo(videoPolygonEntity, {
          duration: 2,
          offset: new Cesium.HeadingPitchRange(
            0,
            Cesium.Math.toRadians(-45),
            500
          ),
        });
        console.log("è§†é¢‘å¤šè¾¹å½¢åˆ›å»ºæˆåŠŸ");
      }

      // åˆ›å»ºå¯ç¼–è¾‘çš„ç‚¹æ ‡è®°
      function createEditablePoints() {
        // æ¸…é™¤æ—§çš„ç‚¹æ ‡è®°
        pointEntities.forEach((entity) => {
          if (entity) viewer.entities.remove(entity);
        });
        pointEntities = [];

        // ä¸ºæ¯ä¸ªé¡¶ç‚¹åˆ›å»ºå¯æ‹–åŠ¨çš„ç‚¹æ ‡è®°
        drawPositions.forEach((position, index) => {
          const pointEntity = viewer.entities.add({
            position: position,
            point: {
              pixelSize: 12,
              color: Cesium.Color.RED,
              outlineColor: Cesium.Color.WHITE,
              outlineWidth: 2,
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
            },
            label: {
              text: `P${index + 1}`,
              font: "12px sans-serif",
              fillColor: Cesium.Color.WHITE,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 2,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
              pixelOffset: new Cesium.Cartesian2(0, -15),
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
            },
            properties: {
              pointIndex: index,
              draggable: true,
            },
          });
          pointEntities.push(pointEntity);
        });
      }

      // æ›´æ–°ç‚¹ä½åˆ—è¡¨æ˜¾ç¤º
      function updatePointList() {
        const pointListSection = document.getElementById("pointListSection");
        const pointList = document.getElementById("pointList");

        pointListSection.style.display = "block";
        pointList.innerHTML = "";

        drawPositions.forEach((position, index) => {
          const cartographic = Cesium.Cartographic.fromCartesian(position);
          const lon = Cesium.Math.toDegrees(cartographic.longitude).toFixed(6);
          const lat = Cesium.Math.toDegrees(cartographic.latitude).toFixed(6);
          const height = cartographic.height.toFixed(2);

          const pointItem = document.createElement("div");
          pointItem.className = "point-item";
          pointItem.innerHTML = `
            <div class="point-item-header">ç‚¹ä½ ${index + 1}</div>
            <div class="point-coords">
              ç»åº¦: ${lon}Â°<br>
              çº¬åº¦: ${lat}Â°<br>
              é«˜åº¦: ${height}m
            </div>
          `;
          pointList.appendChild(pointItem);
        });
      } // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ - å¼€å§‹æ‹–åŠ¨
      handler.setInputAction((movement) => {
        if (!editMode) return;

        const pickedObject = viewer.scene.pick(movement.position);
        if (
          Cesium.defined(pickedObject) &&
          Cesium.defined(pickedObject.id) &&
          pickedObject.id.properties &&
          pickedObject.id.properties.draggable
        ) {
          draggedPointIndex = pickedObject.id.properties.pointIndex;
          viewer.scene.screenSpaceCameraController.enableRotate = false;
          viewer.scene.screenSpaceCameraController.enableTranslate = false;
          viewer.scene.screenSpaceCameraController.enableZoom = false;
          viewer.scene.screenSpaceCameraController.enableTilt = false;
          viewer.scene.screenSpaceCameraController.enableLook = false;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

      // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ - æ‹–åŠ¨ç‚¹ä½æˆ–æ˜¾ç¤ºé¢„è§ˆ
      handler.setInputAction((movement) => {
        // å¦‚æœæ­£åœ¨æ‹–åŠ¨ç‚¹ä½
        if (editMode && draggedPointIndex !== -1) {
          const ray = viewer.camera.getPickRay(movement.endPosition);
          const position = viewer.scene.globe.pick(ray, viewer.scene);

          if (position) {
            // æ›´æ–°ç‚¹ä½ä½ç½®
            drawPositions[draggedPointIndex] = position;
            pointEntities[draggedPointIndex].position = position;

            // æ›´æ–°è§†é¢‘å¤šè¾¹å½¢
            if (videoPolygonEntity) {
              videoPolygonEntity.polygon.hierarchy =
                new Cesium.PolygonHierarchy(drawPositions);
            }

            // æ›´æ–°ç‚¹ä½åˆ—è¡¨
            updatePointList();
          }
          return;
        }

        // å¦‚æœåœ¨æ·»åŠ ç‚¹æ¨¡å¼ï¼Œæ˜¾ç¤ºé¢„è§ˆçº¿
        if (addingPoint) {
          const ray = viewer.camera.getPickRay(movement.endPosition);
          const position = viewer.scene.globe.pick(ray, viewer.scene);

          if (position) {
            const result = findClosestEdge(position);
            if (result) {
              // ç§»é™¤æ—§çš„é¢„è§ˆçº¿
              if (previewLine) {
                viewer.entities.remove(previewLine);
              }

              // åˆ›å»ºæ–°çš„é¢„è§ˆçº¿
              const p1 = drawPositions[result.edgeStartIndex];
              const p2 = drawPositions[result.edgeEndIndex];

              previewLine = viewer.entities.add({
                polyline: {
                  positions: [p1, result.closestPoint, p2],
                  width: 3,
                  material: new Cesium.PolylineDashMaterialProperty({
                    color: Cesium.Color.CYAN,
                    dashLength: 16,
                  }),
                  clampToGround: true,
                },
                point: {
                  position: result.closestPoint,
                  pixelSize: 10,
                  color: Cesium.Color.CYAN,
                  outlineColor: Cesium.Color.WHITE,
                  outlineWidth: 2,
                },
              });
            }
          }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE); // é¼ æ ‡é‡Šæ”¾äº‹ä»¶ - ç»“æŸæ‹–åŠ¨
      handler.setInputAction(() => {
        if (draggedPointIndex !== -1) {
          draggedPointIndex = -1;
          viewer.scene.screenSpaceCameraController.enableRotate = true;
          viewer.scene.screenSpaceCameraController.enableTranslate = true;
          viewer.scene.screenSpaceCameraController.enableZoom = true;
          viewer.scene.screenSpaceCameraController.enableTilt = true;
          viewer.scene.screenSpaceCameraController.enableLook = true;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);

      // æ‰¾åˆ°æœ€è¿‘çš„è¾¹ï¼Œå¹¶è®¡ç®—ç‚¹å‡»ä½ç½®åœ¨è¯¥è¾¹ä¸Šçš„æŠ•å½±ç‚¹
      function findClosestEdge(clickPosition) {
        if (drawPositions.length < 2) return null;

        let minDistance = Infinity;
        let closestEdgeIndex = -1;
        let closestPoint = null;

        // éå†æ‰€æœ‰è¾¹
        for (let i = 0; i < drawPositions.length; i++) {
          const p1 = drawPositions[i];
          const p2 = drawPositions[(i + 1) % drawPositions.length];

          // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„æœ€çŸ­è·ç¦»å’ŒæŠ•å½±ç‚¹
          const result = getClosestPointOnSegment(clickPosition, p1, p2);

          if (result.distance < minDistance) {
            minDistance = result.distance;
            closestEdgeIndex = i;
            closestPoint = result.point;
          }
        }

        if (closestEdgeIndex !== -1) {
          return {
            edgeStartIndex: closestEdgeIndex,
            edgeEndIndex: (closestEdgeIndex + 1) % drawPositions.length,
            insertIndex: closestEdgeIndex + 1,
            closestPoint: closestPoint,
            distance: minDistance,
          };
        }

        return null;
      }

      // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„æœ€çŸ­è·ç¦»å’ŒæŠ•å½±ç‚¹
      function getClosestPointOnSegment(point, lineStart, lineEnd) {
        // å°† Cartesian3 è½¬æ¢ä¸ºå‘é‡
        const ap = Cesium.Cartesian3.subtract(
          point,
          lineStart,
          new Cesium.Cartesian3()
        );
        const ab = Cesium.Cartesian3.subtract(
          lineEnd,
          lineStart,
          new Cesium.Cartesian3()
        );

        const ab2 = Cesium.Cartesian3.dot(ab, ab);
        const ap_ab = Cesium.Cartesian3.dot(ap, ab);

        // è®¡ç®—æŠ•å½±æ¯”ä¾‹
        let t = ap_ab / ab2;

        // é™åˆ¶åœ¨çº¿æ®µèŒƒå›´å†…
        t = Math.max(0, Math.min(1, t));

        // è®¡ç®—æŠ•å½±ç‚¹
        const closestPoint = Cesium.Cartesian3.add(
          lineStart,
          Cesium.Cartesian3.multiplyByScalar(ab, t, new Cesium.Cartesian3()),
          new Cesium.Cartesian3()
        );

        // è®¡ç®—è·ç¦»
        const distance = Cesium.Cartesian3.distance(point, closestPoint);

        return {
          point: closestPoint,
          distance: distance,
        };
      }

      // åŠ è½½ç›¸æœºé…ç½®å¹¶é£è¡Œåˆ°ä½ç½®
      fetch("data/camera_config.json")
        .then((r) => r.json())
        .then((cfg) => {
          console.log("ç›¸æœºé…ç½®åŠ è½½æˆåŠŸ:", cfg);
          const lon = cfg.extrinsic.lon;
          const lat = cfg.extrinsic.lat;
          const height = cfg.extrinsic.height || 500;

          // é£è¡Œåˆ°æŒ‡å®šä½ç½®
          viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(lon, lat, height),
            orientation: {
              heading: Cesium.Math.toRadians(cfg.extrinsic.heading || 0),
              pitch: Cesium.Math.toRadians(cfg.extrinsic.pitch || -45),
              roll: Cesium.Math.toRadians(cfg.extrinsic.roll || 0),
            },
            duration: 3,
            complete: () => {
              console.log("ç›¸æœºå®šä½å®Œæˆ");
              updateStatus("ç›¸æœºå®šä½å®Œæˆ");
            },
          });
        })
        .catch((e) => {
          console.error("åŠ è½½ camera_config.json å¤±è´¥:", e);
          updateStatus("é…ç½®åŠ è½½å¤±è´¥", false);

          // ä½¿ç”¨é»˜è®¤ä½ç½®
          viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(
              121.420765,
              29.67175,
              500
            ),
            duration: 3,
          });
        });

      // è§†é¢‘äº‹ä»¶ç›‘å¬
      video.addEventListener("loadedmetadata", () => {
        console.log("loadedmetadata fired");
        console.log("video size", video.videoWidth, video.videoHeight);
        videoResSpan.textContent = `${video.videoWidth} x ${video.videoHeight}`;
        videoStatus.textContent = "å·²åŠ è½½";

        video
          .play()
          .then(() => {
            console.log("è§†é¢‘è‡ªåŠ¨æ’­æ”¾æˆåŠŸ");
            videoStatus.textContent = "æ’­æ”¾ä¸­";
          })
          .catch((e) => {
            console.warn("è‡ªåŠ¨æ’­æ”¾å¤±è´¥, éœ€è¦ç”¨æˆ·ç‚¹å‡»é¡µé¢è§¦å‘æ’­æ”¾:", e);
            videoStatus.textContent = "ç­‰å¾…æ’­æ”¾";
          });
      });

      video.addEventListener("error", (e) => {
        console.error("è§†é¢‘åŠ è½½é”™è¯¯:", e);
        videoStatus.textContent = "åŠ è½½å¤±è´¥";
        updateStatus("è§†é¢‘åŠ è½½å¤±è´¥", false);
      });

      video.addEventListener("play", () => {
        videoStatus.textContent = "æ’­æ”¾ä¸­";
      });

      video.addEventListener("pause", () => {
        videoStatus.textContent = "å·²æš‚åœ";
      });

      console.log("å¼€å§‹åŠ è½½è§†é¢‘ data/data_clipped_30s.mp4");
      video.load();

      // å…œåº•æ’­æ”¾é€»è¾‘
      document.body.addEventListener(
        "click",
        () => {
          if (video.paused) {
            video
              .play()
              .then(() => {
                console.log("ç”¨æˆ·ç‚¹å‡»åè§†é¢‘å¼€å§‹æ’­æ”¾");
                videoStatus.textContent = "æ’­æ”¾ä¸­";
              })
              .catch((err) => console.error("ç‚¹å‡»åæ’­æ”¾ä»ç„¶å¤±è´¥", err));
          }
        },
        { once: true }
      );
    </script>
  </body>
</html>
```
